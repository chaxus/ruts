# èƒŒæ™¯ä¸èµ·æº

Rust ç”± Graydon Hoare äº 2010 å¹´åˆ›å»ºï¼Œå®ƒçš„è®¾è®¡åˆè¡·æ˜¯ä¸ºäº†æ»¡è¶³ç³»ç»Ÿçº§ç¼–ç¨‹çš„éœ€æ±‚ï¼Œå¹¶å¼¥è¡¥ C++ ç­‰è¯­è¨€çš„ä¸è¶³ã€‚åœ¨ Rust çš„æˆé•¿è¿‡ç¨‹ä¸­ï¼Œå¸æ”¶äº†ä¼—å¤šå‰è¾ˆè¯­è¨€çš„ä¼˜ç‚¹ï¼ŒåŒæ—¶æ‘’å¼ƒäº†å®ƒä»¬çš„ä¸€äº›ç—›ç‚¹ï¼Œä½¿å¾— Rust åœ¨ç³»ç»Ÿç¼–ç¨‹é¢†åŸŸè„±é¢–è€Œå‡ºã€‚

Rust è¯­è¨€ä»¥å…¶å¼ºå¤§çš„å†…å­˜å®‰å…¨æ€§ã€é›¶æˆæœ¬æŠ½è±¡ã€å¹¶å‘æ€§å’Œä¸å¯å˜æ€§è€Œé—»åã€‚å…¶ç‹¬ç‰¹çš„æ‰€æœ‰æƒç³»ç»Ÿä½¿å¾—ç¨‹åºå‘˜èƒ½å¤Ÿåœ¨ä¸ç‰ºç‰²æ€§èƒ½çš„å‰æä¸‹ç¼–å†™å®‰å…¨ã€å¹¶å‘çš„ä»£ç ã€‚è¿™ä½¿å¾— Rust åœ¨ç¼–å†™æ“ä½œç³»ç»Ÿã€åµŒå…¥å¼ç³»ç»Ÿã€ç½‘ç»œæœåŠ¡ä»¥åŠç‰¹åˆ«æ˜¯åŒºå—é“¾é¢†åŸŸè¡¨ç°å‡ºè‰²ã€‚

# å˜é‡

Rust ä¸­çš„å˜é‡å¯ä»¥åˆ†ä¸ºå¯å˜å˜é‡å’Œä¸å¯å˜å˜é‡ï¼Œé€šä¿—æ¥è¯´ï¼Œå°±æ˜¯å˜é‡çš„å€¼æ˜¯å¦å…è®¸ä¿®æ”¹ï¼Œå¦‚æœåœ¨å†…å­˜ä¸­ç»™å˜é‡åˆ†é…å®Œå€¼ä¹‹åï¼Œå¯ä»¥æ ¹æ®éœ€è¦æ¥ä¿®æ”¹è¿™ä¸ªå€¼ï¼Œé‚£å®ƒå°±æ˜¯å¯å˜å˜é‡ï¼Œåä¹‹ï¼Œä¸å…è®¸è¿™ä¸ªå€¼å†å‘ç”Ÿå˜æ›´ï¼Œé‚£å°±æ˜¯ä¸å¯å˜å˜é‡ã€‚å‰è€…å¾ˆå®¹æ˜“ç†è§£ï¼Œå˜é‡çš„å€¼åœ¨ä¸åŒåœºæ™¯ä¸‹ä¼šå‘ç”Ÿå˜åŒ–ï¼Œå®ƒä¸ºç¼–ç¨‹æä¾›äº†çµæ´»æ€§ï¼›åè€…ï¼Œä¹Ÿæœ‰å­˜åœ¨çš„é“ç†ï¼Œé€šè¿‡ä¸å¯å˜çš„é™åˆ¶ï¼Œæä¾›äº†ç¼–ç¨‹çš„å®‰å…¨æ€§ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œä¹Ÿå‡å°‘äº†ä¸€äº›è¿è¡Œæ—¶æ£€æŸ¥ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šæå‡è¿è¡Œæ€§èƒ½ã€‚

> æ³¨æ„ï¼šè¿™é‡Œæåˆ°çš„æ˜¯å¦å¯å˜æŒ‡çš„æ˜¯å˜é‡çš„å€¼ï¼Œè€Œéå˜é‡çš„æ•°æ®ç±»å‹ã€‚

åœºæ™¯ï¼š

ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼Œå‡å¦‚æœ‰ä¸ªå« Ferris çš„åŒå­¦ï¼Œä»å®ƒå‡ºç”Ÿèµ·ï¼Œèº«ä»½è¯å·å°±æ˜¯ä¸å¯å˜çš„ï¼Œä¼´éš Ferris çš„ä¸€ç”Ÿï¼ˆä¸å¯å˜å˜é‡åœ¨å…¶æ•´ä¸ªç”Ÿå‘½å‘¨æœŸä¸­éƒ½æ˜¯ä¸å¯å˜çš„ï¼‰ï¼Œå› ä¸ºä¸å¯å˜ï¼Œæ‰€ä»¥åœ¨æœ‰äº›åœºæ™¯ä¸‹éå¸¸æœ‰ç”¨ï¼Œæ¯”å¦‚å¯ä»¥åœ¨å…¨å›½å…¬å®‰ç³»ç»Ÿä¸­å‡†ç¡®çš„å®šä½åˆ°ä¸€ä¸ªäººï¼›ä½†æ˜¯ï¼Œåƒå®¶åº­ä½å€ã€æ€§åˆ«ï¼ˆNothing is impossibleï¼‰ã€è”ç³»æ–¹å¼ç­‰è¿™äº›ï¼Œå´æœ‰å¯èƒ½å‘ç”Ÿå˜åŒ–ï¼Œè¿™äº›å˜åŒ–å¯¹ Ferris æ¥è¯´ä¹Ÿè®¸æ˜¯éå¸¸æœ‰å¿…è¦çš„ã€‚

> æ³¨ï¼šFerris æ˜¯ Rust ç¤¾åŒºçš„å‰ç¥¥ç‰©ï¼Œå°±æ˜¯é‚£ä¸ªè¢«ç…®ç†Ÿçš„èƒèŸ¹ğŸ¦€ğŸ™ˆ

æˆ‘ä»¬åˆ†åˆ«å®šä¹‰ 2 ä¸ªä¸åŒç±»å‹çš„å˜é‡ï¼Œå¹¶å°è¯•ä¿®æ”¹å¯¹åº”çš„å€¼ã€‚

```rs
fn main() {
    // x ä¸ºå¯å˜å˜é‡ï¼Œmut å³ mutable çš„æ„æ€ï¼Œè¯¥ä¿®é¥°ç¬¦ä¿®é¥°çš„å˜é‡å…è®¸æ”¹å˜
    let mut x = 1;
    println!("x = {}", x);
    x = 2;
    println!("x = {}", x);

    // y ä¸ºä¸å¯å˜å˜é‡ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®š mutï¼Œåˆ™ Rust é»˜è®¤ä¸ºä¸å¯å˜
    let y = 3;
    println!("y = {}", y);
    // å¯¹ä¸å¯å˜å˜é‡ y é‡æ–°èµ‹å€¼ï¼ŒRust ç¼–è¯‘å™¨ä¼šç»™å‡º cannot assign twice to immutable variable y çš„é”™è¯¯æç¤º
    y = 4;
    println!("y = {}", y);
}
```

## å˜é‡çš„è§£æ„

å˜é‡è§£æ„æ˜¯ä¸€ç§å°†å¤åˆæ•°æ®ç±»å‹ï¼ˆå¦‚å…ƒç»„ã€ç»“æ„ä½“ã€æšä¸¾ç­‰ï¼‰ä¸­çš„å€¼åˆ†è§£ä¸ºå•ç‹¬å˜é‡çš„è¿‡ç¨‹ã€‚å®ƒå¯ä»¥æ–¹ä¾¿åœ°ä»å¤æ‚çš„æ•°æ®ç»“æ„ä¸­æå–å‡ºéœ€è¦çš„å€¼ï¼Œå¹¶ä»¥æ›´ç®€æ´çš„æ–¹å¼è¿›è¡Œæ“ä½œã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯ä»¥æ›´å¥½çš„æ§åˆ¶æ•°æ®çš„å¯è§æ€§ï¼Œä¹Ÿä½¿å¾—ä»£ç æ›´åŠ ä¼˜é›…ã€‚å˜é‡è§£æ„é€šä¿—æ¥è®²å°±æ˜¯å·²çŸ¥åŸæœ‰çš„ç»“æ„ï¼Œè§£å¼€è¯¥ç»“æ„ã€‚å®ƒå¹¶ä¸æ˜¯ Rust ç‹¬æœ‰çš„ç‰¹æ€§ï¼ŒPythonã€JavaScriptã€Solidity ç­‰è®¸å¤šç¼–ç¨‹è¯­è¨€ä¹Ÿéƒ½æœ‰ã€‚

æˆ‘ä»¬å¯ä»¥é€šè¿‡å¦‚ä¸‹çš„æ–¹å¼ï¼ŒæŠŠæ°´æœç¯®é‡Œçš„é¦™è•‰ã€è èã€æ¦´è²æ”¾åœ¨ aã€bã€c ä¸‰ä¸ªä¸åŒçš„ç›˜å­é‡Œï¼Œæˆ–è€…æ¢ä¸€ç§æ–¹å¼ï¼Œåªæ‹¿é¦™è•‰å’Œè èã€‚

```rs
// ç¬¬ä¸€ç§æ”¾æ³•
let (a, b, c) = ("Banana", "pineapple", "durian");

// ç¬¬äºŒç§æ”¾æ³•
let (e, d, _) = ("Banana", "pineapple", "durian");
```

# æ•°å€¼ç±»å‹

Rust åŸºæœ¬æ•°æ®ç±»å‹ä¸­æœ€å¸¸ç”¨çš„æ•°å€¼ç±»å‹ï¼šæœ‰ç¬¦å·æ•´æ•° (i8, i16, i32, i64, isize)ã€æ— ç¬¦å·æ•´æ•° (u8, u16, u32, u64, usize) ã€æµ®ç‚¹æ•° (f32, f64)ã€‚æ•´æ•°æ˜¯ æ²¡æœ‰å°æ•°éƒ¨åˆ†çš„æ•°å­—ï¼Œå…·ä½“æœ‰å¦‚ä¸‹å‡ ç§ç±»å‹ï¼š

![](./assets/rust-variable.webp)

è¡¨ç¤ºæ–¹å¼ä¸ºï¼š

- æœ‰æ— ç¬¦å· + ç±»å‹å¤§å°ï¼ˆä½æ•°ï¼‰ã€‚i æ˜¯è‹±æ–‡å•è¯ integer çš„é¦–å­—æ¯ï¼Œä»£è¡¨æœ‰ç¬¦å·ç±»å‹ï¼ŒåŒ…å«è´Ÿæ•´æ•°ã€0 å’Œæ­£æ•´æ•°ï¼Œä¸ä¹‹ç›¸åçš„æ˜¯ uï¼Œä»£è¡¨æ— ç¬¦å· unsigned ç±»å‹ï¼ŒåŒ…å« 0 å’Œæ­£æ•´æ•°ã€‚
- Rust é»˜è®¤çš„æ•´æ•°ç±»å‹æ˜¯ i32ï¼Œå³ç”¨ 32 ä¸ª bit ä½è¡¨ç¤ºæœ‰ç¬¦å·çš„æ•´æ•°ã€‚
- æµ®ç‚¹ç±»å‹æ•°å­—ï¼šæ˜¯å¸¦æœ‰å°æ•°ç‚¹çš„æ•°å­—ï¼Œåœ¨ Rust ä¸­æµ®ç‚¹ç±»å‹æ•°å­—ä¹Ÿæœ‰ä¸¤ç§åŸºæœ¬ç±»å‹ï¼šf32 å’Œ f64ï¼Œåˆ†åˆ«ä¸º 32 ä½å’Œ 64 ä½å¤§å°ã€‚é»˜è®¤æµ®ç‚¹ç±»å‹æ˜¯ f64ã€‚

æˆ‘ä»¬åœ¨æ¥ä¸‹æ¥çœ‹ä¸‹æ•°å€¼çš„å®šä¹‰åŠè¡¨ç¤ºæ–¹å¼ã€‚

```rs
// è¿™é‡Œ a ä¸ºé»˜è®¤çš„ i32 ç±»å‹
let a = 1;
// å¯ä»¥æŒ‡å®šä¹Ÿå¯ä»¥æŒ‡å®šä¸ºå…·ä½“çš„æ•´æ•°ç±»å‹
let b: u32 = 1;

// è¿™é‡Œ c ä¸ºé»˜è®¤çš„ f64 ç±»å‹
let c = 1.0;
// ä¹Ÿå¯ä»¥æŒ‡å®šä¸ºå…·ä½“çš„æµ®ç‚¹æ•°ç±»å‹
let d: f32 = 1.0;

// Rust ä¸­å¯ä»¥æ–¹ä¾¿çš„ä½¿ç”¨ä¸åŒè¿›åˆ¶æ¥è¡¨ç¤ºæ•°å€¼ï¼Œæ€»æœ‰ä¸€æ¬¾é€‚åˆä½ 
let x: i32 = 100_000_000;
let y: i32 = 0xffab;
let z: i32 = 0o77;
let m: i32 = 0b1111_0000;
let n: u8 = b'A';
println!("x = {}, y = {}, z = {}, m = {}, n = {}", x, y, z, m, n);
```

# å­—ç¬¦ç±»å‹ä¸å¸ƒå°”ç±»å‹

å­—ç¬¦ç±»å‹æ˜¯ç”¨ char ç±»å‹è¡¨ç¤ºçš„ï¼Œå ç”¨ 4 ä¸ªå­—èŠ‚çš„ç©ºé—´ï¼Œå¯ä»¥è¡¨ç¤º Unicode å­—ç¬¦é›†ä¸­çš„ä»»ä½•å­—ç¬¦ï¼ŒåŒ…æ‹¬ ASCII å­—ç¬¦ã€å„ç§ç¬¦å·ã€å„ç§è¯­è¨€çš„æ–‡å­—ï¼Œç”šè‡³æ˜¯è¡¨æƒ…ç¬¦å·ã€‚é€šè¿‡å•å¼•å·'å¯ä»¥åˆ›å»ºä¸€ä¸ª char ç±»å‹çš„å€¼ã€‚ä¾‹å¦‚ let a:char = 'ğŸ¦€';

å¸ƒå°”ç±»å‹æœ‰ä¸¤ç§å€¼ï¼štrue å’Œ falseï¼Œå ç”¨å†…å­˜çš„å¤§å°ä¸º 1 ä¸ªå­—èŠ‚ã€‚

æ³¨æ„ï¼šè¿™é‡Œæ˜¯ä»‹ç»çš„æ˜¯å­—ç¬¦ï¼ˆç”¨å•å¼•å·''è¡¨ç¤º)ï¼Œä¸æ˜¯å­—ç¬¦ä¸² (ç”¨åŒå¼•å·""è¡¨ç¤º)ï¼Œåœ¨ Rust ä¸­ï¼Œå­—ç¬¦ä¸²ç±»å‹çš„é•¿åº¦å–å†³äºä½¿ç”¨çš„ç¼–ç é›†ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼ŒRust ä½¿ç”¨ UTF-8 ç¼–ç ï¼Œä¸€ä¸ªå­—ç¬¦å ç”¨ 1ï½4 ä¸ªå­—èŠ‚ï¼Œè€Œ char ç±»å‹å ç”¨ 4 ä¸ªå­—èŠ‚çš„å­˜å‚¨ç©ºé—´ï¼Œå³ä½¿æœ‰äº›å­—ç¬¦åœ¨ç‰¹å®šç¼–ç é›†ä¸‹åªéœ€è¦ 1ï½3 ä¸ªå­—èŠ‚è¡¨ç¤ºï¼ŒRust ä¹Ÿä¼šå°†å…¶æ‰©å±•ä¸º 4 ä¸ªå­—èŠ‚ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼š

â— ä¿è¯æ‰€æœ‰ char å€¼åœ¨å†…å­˜ä¸­å ç”¨å›ºå®šå¤§å°ï¼Œæœ‰åˆ©äºå†…å­˜å¯¹é½å’Œè®¿é—®æ•ˆç‡ã€‚

â— é¿å…ç¼–ç è½¬æ¢å¼€é”€ï¼Œç›´æ¥ä½¿ç”¨ 4 å­—èŠ‚å€¼å¯ä»¥é«˜æ•ˆå¤„ç†å­—ç¬¦ã€‚

â— è¶³å¤Ÿè¡¨ç¤º Unicode æ ‡é‡å€¼æ‰€éœ€çš„å…¨éƒ¨ç ä½ï¼Œç¡®ä¿æœªæ¥çš„å…¼å®¹æ€§ã€‚

```rs
// è‹±æ–‡å­—ç¬¦
let c = 'z';
// æ•°å­¦ç¬¦å·
let z = 'â„¤';
// ä¸­æ–‡å­—ç¬¦
let g = 'å›½';
// emoji è¡¨æƒ…
let ferris = 'ğŸ¦€';

// å¸ƒå°”ç±»å‹
let m = true;
```

# è¯­å¥ï¼Œè¡¨è¾¾å¼ï¼Œå•å…ƒç±»å‹

è¯­å¥ï¼ˆStatementsï¼‰æ˜¯ Rust ä¸­çš„æ‰§è¡Œå•ä½ï¼Œå®ƒä»¬æ‰§è¡Œä¸€äº›æ“ä½œä½†ä¸è¿”å›å€¼ï¼Œä»¥åˆ†å·;ç»“å°¾ã€‚

è¡¨è¾¾å¼ï¼ˆExpressionsï¼‰æ˜¯ Rust ä¸­çš„è®¡ç®—å•ä½ï¼Œå®ƒä»¬è®¡ç®—å¹¶è¿”å›ä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥è¡¨è¾¾å¼å¯ä»¥ç”¨ä½œèµ‹å€¼ã€‚å¸¸è§çš„è¡¨è¾¾å¼æœ‰å‡½æ•°è°ƒç”¨ã€å®è°ƒç”¨ã€ç”¨å¤§æ‹¬å·åˆ›å»ºçš„ä»£ç å—ç­‰ã€‚

å•å…ƒç±»å‹ï¼šæ˜¯ Rust ä¸­ä¸€ä¸ªç‰¹æ®Šçš„è¿”å›å€¼ç±»å‹ï¼Œæ„å‘³ç€å‡½æ•°æˆ–è¡¨è¾¾å¼æ²¡æœ‰è¿”å›å€¼ï¼Œç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„ void çš„è¿”å›ç±»å‹ã€‚ç”¨ç¬¦å· () æ¥è¡¨ç¤ºã€‚

> å°æŠ€å·§ï¼šåŒºåˆ†è¯­å¥å’Œè¡¨è¾¾å¼çš„ä¸€ä¸ªç®€å•æ–¹æ³•å°±æ˜¯æœ‰æ— åˆ†å·;ï¼Œæœ‰çš„è¯å°±æ˜¯è¯­å¥ï¼Œæ‰§è¡Œæ“ä½œä½†ä¸è¿”å›ç»“æœï¼›æ²¡æœ‰çš„è¯å°±æ˜¯è¡¨è¾¾å¼ï¼Œæ‰§è¡Œè®¡ç®—å¹¶è¿”å›ç»“æœã€‚è™½ç„¶è¿™ç§æ–¹å¼åœ¨æœ‰äº›æƒ…å†µä¸‹ä¸æˆç«‹ï¼Œä½†ç°é˜¶æ®µè¶³ä»¥è®©æˆ‘ä»¬åº”å¯¹ç»å¤§æ•°åœºæ™¯ã€‚

```rs
fn main() {
    // è¯­å¥ï¼Œä½¿ç”¨ let å…³é”®å­—åˆ›å»ºå˜é‡å¹¶ç»‘å®šä¸€ä¸ªå€¼
    let a = 1;

    // è¯­å¥ä¸è¿”å›å€¼ï¼Œæ‰€ä»¥ä¸èƒ½æŠŠè¯­å¥ (let a = 1) ç»‘å®šç»™å˜é‡ bï¼Œä¸‹é¢ä»£ç ä¼šç¼–è¯‘å¤±è´¥
    let b = (let a = 1);

    // è¡¨è¾¾å¼ï¼Œè¿”å›å€¼æ˜¯ x + 1
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y); // y = 4
}
```

## å•å…ƒç±»å‹çš„ä¾‹å­

å•å…ƒç±»å‹ `()` åœ¨ Rust ä¸­éå¸¸å¸¸è§ï¼Œä»¥ä¸‹æ˜¯ä¸€äº›å…¸å‹çš„ä¾‹å­ï¼š

### 1. å‡½æ•°è¿”å›å•å…ƒç±»å‹

```rs
// æ²¡æœ‰æ˜¾å¼è¿”å›å€¼çš„å‡½æ•°ï¼Œé»˜è®¤è¿”å›å•å…ƒç±»å‹ ()
fn greet(name: &str) {
    println!("Hello, {}!", name);
    // è¿™é‡Œæ²¡æœ‰ return è¯­å¥ï¼Œå‡½æ•°éšå¼è¿”å› ()
}

// æ˜¾å¼è¿”å›å•å…ƒç±»å‹
fn do_nothing() -> () {
    println!("I do nothing");
    () // æ˜¾å¼è¿”å›å•å…ƒç±»å‹
}

fn main() {
    let result1 = greet("Ferris"); // result1 çš„ç±»å‹æ˜¯ ()
    let result2 = do_nothing();    // result2 çš„ç±»å‹æ˜¯ ()

    // å¯ä»¥æ˜¾å¼æŒ‡å®šå•å…ƒç±»å‹
    let unit_value: () = ();
    println!("Unit value: {:?}", unit_value); // è¾“å‡ºï¼šUnit value: ()
}
```

### 2. if è¯­å¥è¿”å›å•å…ƒç±»å‹

```rs
fn main() {
    let condition = true;

    // if è¯­å¥çš„æ¯ä¸ªåˆ†æ”¯éƒ½è¿”å›å•å…ƒç±»å‹
    let result = if condition {
        println!("Condition is true");
        // è¿™é‡Œæ²¡æœ‰åˆ†å·ï¼Œè¿”å› ()
    } else {
        println!("Condition is false");
        // è¿™é‡Œæ²¡æœ‰åˆ†å·ï¼Œè¿”å› ()
    };

    // result çš„ç±»å‹æ˜¯ ()
    println!("Result type: {:?}", result);
}
```

### 3. å¾ªç¯è¿”å›å•å…ƒç±»å‹

```rs
fn main() {
    let mut counter = 0;

    // loop å¾ªç¯é»˜è®¤è¿”å›å•å…ƒç±»å‹
    let loop_result = loop {
        counter += 1;
        if counter >= 3 {
            break; // break ä¸è¿”å›å€¼ï¼Œæ‰€ä»¥æ•´ä¸ªå¾ªç¯è¿”å› ()
        }
    };

    // while å¾ªç¯ä¹Ÿè¿”å›å•å…ƒç±»å‹
    let while_result = while counter < 5 {
        counter += 1;
        // æ²¡æœ‰è¿”å›å€¼ï¼Œè¿”å› ()
    };

    // for å¾ªç¯åŒæ ·è¿”å›å•å…ƒç±»å‹
    let for_result = for i in 1..=3 {
        println!("Count: {}", i);
        // æ²¡æœ‰è¿”å›å€¼ï¼Œè¿”å› ()
    };

    println!("All loops return unit type: {:?}", loop_result);
}
```

### 4. ä»£ç å—è¿”å›å•å…ƒç±»å‹

```rs
fn main() {
    // ä»£ç å—ä»¥åˆ†å·ç»“å°¾ï¼Œè¿”å›å•å…ƒç±»å‹
    let block_result = {
        let x = 5;
        let y = 10;
        println!("x = {}, y = {}", x, y);
        // è¿™é‡Œæ²¡æœ‰åˆ†å·ï¼Œä½† println! å®è¿”å› ()
    };

    // æ˜¾å¼è¿”å›å•å…ƒç±»å‹çš„ä»£ç å—
    let explicit_unit = {
        let _unused = 42;
        () // æ˜¾å¼è¿”å›å•å…ƒç±»å‹
    };

    println!("Block results: {:?}, {:?}", block_result, explicit_unit);
}
```

### 5. ç»“æ„ä½“æ–¹æ³•è¿”å›å•å…ƒç±»å‹

```rs
struct Person {
    name: String,
    age: u32,
}

impl Person {
    // æ–¹æ³•ä¸è¿”å›å€¼ï¼Œè¿”å›å•å…ƒç±»å‹
    fn introduce(&self) {
        println!("Hi, I'm {} and I'm {} years old", self.name, self.age);
    }

    // æ˜¾å¼æŒ‡å®šè¿”å›å•å…ƒç±»å‹
    fn celebrate_birthday(&mut self) -> () {
        self.age += 1;
        println!("Happy birthday! Now I'm {} years old", self.age);
    }
}

fn main() {
    let mut person = Person {
        name: String::from("Ferris"),
        age: 25,
    };

    let intro_result = person.introduce(); // è¿”å› ()
    let birthday_result = person.celebrate_birthday(); // è¿”å› ()

    println!("Method results: {:?}, {:?}", intro_result, birthday_result);
}
```

### 6. é”™è¯¯å¤„ç†ä¸­çš„å•å…ƒç±»å‹

```rs
use std::fs;

fn main() -> Result<(), std::io::Error> {
    // åˆ›å»ºæ–‡ä»¶ï¼ŒæˆåŠŸæ—¶è¿”å›å•å…ƒç±»å‹
    fs::write("test.txt", "Hello, Rust!")?;

    // åˆ é™¤æ–‡ä»¶ï¼ŒæˆåŠŸæ—¶è¿”å›å•å…ƒç±»å‹
    fs::remove_file("test.txt")?;

    Ok(()) // æ˜¾å¼è¿”å›å•å…ƒç±»å‹
}
```

è¿™äº›ä¾‹å­å±•ç¤ºäº†å•å…ƒç±»å‹åœ¨ Rust ä¸­çš„å¹¿æ³›åº”ç”¨ã€‚å•å…ƒç±»å‹è™½ç„¶ä¸æºå¸¦ä»»ä½•æ•°æ®ï¼Œä½†åœ¨ç±»å‹ç³»ç»Ÿä¸­èµ·ç€é‡è¦ä½œç”¨ï¼Œç¡®ä¿ç±»å‹å®‰å…¨å’Œä»£ç çš„æ¸…æ™°æ€§ã€‚

Rust ä¸ºä»€ä¹ˆè¦è®¾è®¡æ²¡æœ‰ä»»ä½•è¿”å›å€¼çš„å•å…ƒç±»å‹ () ?

Rust æ˜¯ä¸€é—¨é™æ€ç±»å‹è¯­è¨€ï¼Œå®ƒåœ¨ç¼–è¯‘æ—¶éœ€è¦ç¡®å®šæ¯ä¸ªå‡½æ•°çš„è¿”å›ç±»å‹ã€‚

å½“å‡½æ•°ä½“ä¸­æ²¡æœ‰è¿”å›è¯­å¥æˆ–è¡¨è¾¾å¼æ—¶ï¼Œç¼–è¯‘å™¨æ— æ³•ç¡®å®šå‡½æ•°çš„è¿”å›ç±»å‹åº”è¯¥æ˜¯ä»€ä¹ˆã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒRust å¼•å…¥äº†å•å…ƒç±»å‹ () ä½œä¸ºä¸€ç§ç‰¹æ®Šçš„ç±»å‹ï¼Œè¡¨ç¤ºæ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°ã€‚ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„ void ç±»å‹ï¼Œé€šå¸¸ç”¨äºæ‰“å°æ¶ˆæ¯ã€å†™å…¥æ–‡ä»¶ç­‰ä¸€äº›ä¸éœ€è¦è¿”å›å€¼çš„æ“ä½œã€‚

# å‡½æ•°

å‡½æ•°æ˜¯ä¸ªå¾ˆå¸¸è§çš„æ¦‚å¿µï¼Œå®ƒæ˜¯ä¸€æ®µå¯é‡å¤ä½¿ç”¨çš„ä»£ç å—ï¼Œç”¨äºæ‰§è¡Œç‰¹å®šçš„ä»»åŠ¡æˆ–å®Œæˆç‰¹å®šçš„æ“ä½œã€‚å‡½æ•°æ¥å—è¾“å…¥å‚æ•°ï¼ˆå¯é€‰ï¼‰ï¼Œæ‰§è¡Œä¸€ç³»åˆ—æ“ä½œï¼Œå¹¶è¿”å›ä¸€ä¸ªå€¼ï¼ˆå¯é€‰ï¼‰ã€‚

> æ³¨æ„ï¼šRust ä»£ç ä¸­çš„å‡½æ•°å’Œå˜é‡åä½¿ç”¨ snake_case è§„èŒƒé£æ ¼ã€‚

ç°åœ¨æˆ‘ä»¬æ¥çœ‹ä¸‹å‡½æ•°çš„å„ä¸ªç»„æˆéƒ¨åˆ†ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå‡½æ•°çš„å‚æ•°éœ€è¦æ˜¾å¼çš„æ ‡æ³¨ç±»å‹ï¼Œä¸ä»…æœ‰åŠ©äºæé«˜ä»£ç çš„å¯è¯»æ€§ï¼Œä¹Ÿæœ‰åŠ©äº Rust æä¾›æ›´å¼ºçš„ç±»å‹å®‰å…¨æ€§ï¼Œå¸®åŠ©ç¼–è¯‘å™¨åœ¨ç±»å‹ä¸åŒ¹é…æ—¶å‘ç°é”™è¯¯ï¼Œæä¾›æœ‰ç”¨çš„é”™è¯¯ä¿¡æ¯ã€‚

```rs
// fn ä¸ºå£°æ˜å‡½æ•°çš„å…³é”®å­—
// unsafe_add() æ˜¯å‡½æ•°åï¼Œå‡½æ•°çš„å‘½åè¦éµå¾ª snake_case çš„è§„èŒƒï¼ŒåŒæ—¶è¦è§åçŸ¥æ„ï¼Œæé«˜ä»£ç çš„å¯è¯»æ€§
// i å’Œ j æ˜¯å…¥å‚ï¼Œå¹¶ä¸”éœ€è¦æ˜¾å¼æŒ‡å®šå‚æ•°ç±»å‹
// --> i32 è¡¨æ˜å‡ºå‚ä¹Ÿæ˜¯ i32 ç±»å‹
fn unsafe_add(i: i32, j: i32) -> i32 {
   // è¡¨è¾¾å¼å½¢å¼ï¼Œæ‰€ä»¥å‡½æ•°ä¼šåœ¨è®¡ç®—æ±‚å’Œåè¿”å›è¯¥å€¼
   i + j
}
```

æˆ‘ä»¬åœ¨å‰é¢ç« èŠ‚äº†è§£åˆ°æ•´æ•°ç›¸åŠ å¯èƒ½ä¼šæº¢å‡ºï¼Œä½†è¿™é‡Œå¹¶æ²¡æœ‰ç‰¹æ®Šå¤„ç†ï¼Œæ‰€ä»¥ unsafe_add æ›´å®¹æ˜“æé†’å¼€å‘è€…ï¼Œè¿™ä¸ªç›¸åŠ æ˜¯ä¸å®‰å…¨çš„ï¼Œè¦æ³¨æ„å•¦~

## å‘æ•£å‡½æ•°ï¼ˆDiverging Functionsï¼‰

æŒ‡çš„æ˜¯æ°¸è¿œä¸ä¼šè¿”å›çš„å‡½æ•°ï¼Œç”šè‡³è¿é»˜è®¤çš„å•å…ƒç±»å‹ () è¿”å›å€¼éƒ½æ²¡æœ‰ï¼Œè¿™äº›å‡½æ•°é€šå¸¸ç”¨ï¼ç±»å‹æ¥æ ‡æ³¨ã€‚é€šå¸¸ç”¨äºå¤„ç†é”™è¯¯æˆ–ä¸å¯æ¢å¤çš„æƒ…å†µï¼Œå¹¶é€šè¿‡ç»ˆæ­¢ç¨‹åºçš„æ‰§è¡Œæ¥è¡¨è¾¾è¿™ç§çŠ¶æ€ã€‚

```rs
// å‘æ•£å‡½æ•°çš„ä¾‹å­

// 1. ä½¿ç”¨ panic! å®çš„å‡½æ•°
fn panic_function() -> ! {
    panic!("This function will never return normally");
}

// 2. æ— é™å¾ªç¯å‡½æ•°
fn infinite_loop() -> ! {
    loop {
        println!("This will run forever");
        // æ²¡æœ‰ break è¯­å¥ï¼Œæ‰€ä»¥æ°¸è¿œä¸ä¼šé€€å‡º
    }
}

// 3. ä½¿ç”¨ unreachable! å®çš„å‡½æ•°
fn unreachable_function(x: i32) -> ! {
    if x > 0 {
        panic!("Positive number encountered");
    } else if x < 0 {
        panic!("Negative number encountered");
    } else {
        unreachable!("This code should never be reached");
    }
}

// 4. é€’å½’è°ƒç”¨è‡ªèº«çš„å‡½æ•°
fn recursive_panic(n: u32) -> ! {
    if n == 0 {
        panic!("Reached the end");
    } else {
        println!("Countdown: {}", n);
        recursive_panic(n - 1); // é€’å½’è°ƒç”¨ï¼Œæœ€ç»ˆä¼š panic
    }
}

// 5. åœ¨ match è¯­å¥ä¸­ä½¿ç”¨å‘æ•£å‡½æ•°
fn match_with_diverging(x: Option<i32>) -> i32 {
    match x {
        Some(value) => value,
        None => {
            // è¿™é‡Œè°ƒç”¨å‘æ•£å‡½æ•°ï¼Œç¼–è¯‘å™¨çŸ¥é“è¿™ä¸ªåˆ†æ”¯æ°¸è¿œä¸ä¼šè¿”å›
            panic!("Expected Some value, got None");
        }
    }
}

// 6. ä½¿ç”¨ std::process::exit çš„å‡½æ•°
use std::process;

fn exit_program() -> ! {
    println!("Exiting program...");
    process::exit(1); // ç¨‹åºç«‹å³é€€å‡ºï¼Œæ°¸è¿œä¸ä¼šè¿”å›
}

fn main() {
    // æ¼”ç¤ºå‘æ•£å‡½æ•°çš„ä½¿ç”¨

    // æ³¨æ„ï¼šä»¥ä¸‹ä»£ç ä¼šç»ˆæ­¢ç¨‹åºï¼Œæ‰€ä»¥æ³¨é‡Šæ‰
    // panic_function();
    // infinite_loop();
    // unreachable_function(0);
    // recursive_panic(5);
    // exit_program();

    // æ¼”ç¤ºåœ¨ match ä¸­çš„ä½¿ç”¨
    let result = match_with_diverging(Some(42));
    println!("Result: {}", result);

    // è¿™ä¸ªä¼š panic
    // let result = match_with_diverging(None);

    println!("Program completed successfully");
}
```

### å‘æ•£å‡½æ•°çš„ç‰¹ç‚¹

1. **è¿”å›ç±»å‹ä¸º `!`**ï¼š`!` æ˜¯ Rust ä¸­çš„"never"ç±»å‹ï¼Œè¡¨ç¤ºå‡½æ•°æ°¸è¿œä¸ä¼šæ­£å¸¸è¿”å›
2. **ç¨‹åºç»ˆæ­¢**ï¼šå‘æ•£å‡½æ•°é€šå¸¸ä¼šå¯¼è‡´ç¨‹åº panic æˆ–é€€å‡º
3. **ç±»å‹å®‰å…¨**ï¼šç¼–è¯‘å™¨çŸ¥é“è¿™äº›å‡½æ•°ä¸ä¼šè¿”å›ï¼Œå› æ­¤å¯ä»¥åœ¨ç±»å‹æ£€æŸ¥ä¸­åˆ©ç”¨è¿™ä¸ªä¿¡æ¯
4. **å¸¸è§ç”¨é€”**ï¼š
   - é”™è¯¯å¤„ç†ï¼šå½“é‡åˆ°ä¸å¯æ¢å¤çš„é”™è¯¯æ—¶
   - æ— é™å¾ªç¯ï¼šå¦‚äº‹ä»¶å¾ªç¯ã€æœåŠ¡å™¨ä¸»å¾ªç¯
   - ç¨‹åºé€€å‡ºï¼šæ¸…ç†èµ„æºåé€€å‡ºç¨‹åº

### å‘æ•£å‡½æ•°åœ¨ç±»å‹ç³»ç»Ÿä¸­çš„ä½œç”¨

```rs
fn example_with_diverging() {
    let x = if true {
        42
    } else {
        // ç¼–è¯‘å™¨çŸ¥é“è¿™ä¸ªåˆ†æ”¯æ°¸è¿œä¸ä¼šæ‰§è¡Œï¼Œå› ä¸ºæ¡ä»¶æ€»æ˜¯ true
        // ä½†å³ä½¿å¦‚æ­¤ï¼Œè¿™ä¸ªåˆ†æ”¯çš„è¿”å›ç±»å‹å¿…é¡»ä¸ if åˆ†æ”¯åŒ¹é…
        panic!("This will never happen");
    };

    println!("x = {}", x); // x çš„ç±»å‹æ˜¯ i32ï¼Œä¸æ˜¯ !
}
```

å‘æ•£å‡½æ•°æ˜¯ Rust ç±»å‹ç³»ç»Ÿçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œå®ƒä»¬å¸®åŠ©ç¼–è¯‘å™¨è¿›è¡Œæ›´ç²¾ç¡®çš„ç±»å‹æ¨æ–­å’Œé”™è¯¯æ£€æŸ¥ã€‚

# æ ˆå†…å­˜å’Œå †å†…å­˜

æ ˆå†…å­˜å­˜å‚¨çš„æ•°æ®ä¸»è¦ä¸ºå¤§å°å›ºå®šçš„åŸºç¡€æ•°æ®ç±»å‹ï¼Œåˆ†é…å’Œé‡Šæ”¾é€Ÿåº¦å¾ˆå¿«ï¼›å®ƒä»¥æ”¾å…¥å€¼çš„é¡ºåºå­˜å‚¨å€¼å¹¶ä»¥ç›¸åé¡ºåºå–å‡ºå€¼ã€‚è¿™ä¹Ÿè¢«ç§°ä½œ åè¿›å…ˆå‡ºï¼ˆlast in, first outï¼‰ã€‚

å‰é¢ä»‹ç»è¿‡ Rust çš„åŸºç¡€ç±»å‹ï¼ši32ã€charã€f64ã€bool ç­‰ï¼Œå®ƒä»¬éƒ½æ˜¯å·²çŸ¥å¤§å°çš„ï¼Œå­˜å‚¨åœ¨æ ˆå†…å­˜ä¸­

å †å†…å­˜å­˜å‚¨é‚£äº›å¤§å°åœ¨è¿è¡Œæ—¶åŠ¨æ€å˜åŒ–çš„æ•°æ®ç»“æ„ï¼Œå…è®¸æ›´çµæ´»çš„æ•°æ®å…±äº«å’ŒåŠ¨æ€åˆ†é…ï¼›å½“å‘å †æ”¾å…¥æ•°æ®æ—¶ï¼Œå†…å­˜åˆ†é…å™¨ï¼ˆmemory allocatorï¼‰åœ¨å †çš„æŸå¤„æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„ç©ºä½ï¼ŒæŠŠå®ƒæ ‡è®°ä¸ºå·²ä½¿ç”¨ï¼Œå¹¶è¿”å›ä¸€ä¸ªè¡¨ç¤ºè¯¥ä½ç½®åœ°å€çš„æŒ‡é’ˆï¼ˆpointerï¼‰ã€‚æ€»çš„æ¥è¯´ï¼Œå †ã€æ ˆå†…å­˜å¹¶æ— ä¼˜åŠ£ä¹‹åˆ†ï¼Œåªæ˜¯é¢å‘çš„åœºæ™¯ä¸åŒè€Œå·²ã€‚

æ¯”å¦‚åŠ¨æ€å­—ç¬¦ä¸²ï¼ˆString ç±»å‹ï¼‰ï¼šå¤§å°å¯å˜çš„å­—ç¬¦é›†åˆï¼Œè¿™ä¸ªç±»å‹å…è®¸ç¨‹åºåœ¨è¿è¡Œæ—¶åŠ¨æ€çš„ç®¡ç†å †å†…å­˜ä¸Šçš„å­—ç¬¦ä¸²æ•°æ®ï¼Œæ¯”å¦‚åˆ†é…ã€å¢é•¿å’Œä¿®æ”¹å­—ç¬¦ä¸²å†…å®¹ï¼Œæ‰€ä»¥èƒ½å¤Ÿå­˜å‚¨åœ¨ç¼–è¯‘æ—¶æœªçŸ¥å¤§å°çš„å†…å®¹ã€‚

é€šè¿‡ä¸‹é¢çš„ä»£ç ï¼Œæˆ‘ä»¬çœ‹ä¸‹åŠ¨æ€å­—ç¬¦ä¸²çš„åˆ›å»ºã€‚

```rs
use std::io;
fn main() {
     // åˆ›å»ºä¸€ä¸ªå¯å˜çš„å­—ç¬¦ä¸²å˜é‡æ¥å­˜å‚¨ç”¨æˆ·è¾“å…¥
    let mut input: String = String::new();
    println!("è¯·è¾“å…¥æ‚¨çš„åå­—ï¼š");
    // è¯»å–ç”¨æˆ·è¾“å…¥å¹¶å°†å…¶å­˜å‚¨åœ¨ input å˜é‡ä¸­
    io::stdin()
        .read_line(&mut input)
        .expect("æ— æ³•è¯»å–è¾“å…¥");
    // æ‰“å°ç”¨æˆ·è¾“å…¥çš„å­—ç¬¦ä¸²
    println!("æ‚¨çš„åå­—æ˜¯ï¼š{}", input);
}
```

# æ‰€æœ‰æƒ

Rust ä¸­æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„æ‰€æœ‰è€… ownerï¼ˆå¦‚ä¸ŠèŠ‚ä»£ç  let s1 = String::from("hello");ä¸­ï¼Œå˜é‡ s1 æ˜¯ hello è¿™ä¸ªå€¼çš„æ‰€æœ‰è€…ï¼‰ï¼Œæ‰€æœ‰è€…æ‹¥æœ‰è¿™ä¸ªå€¼çš„æ‰€æœ‰æƒï¼Œè´Ÿè´£ç®¡ç†å†…å­˜èµ„æºçš„åˆ†é…å’Œé‡Šæ”¾ã€‚Rust é€šè¿‡æ‰€æœ‰æƒæœºåˆ¶è§„å®šå†…å­˜ç®¡ç†çš„æ–¹å¼ï¼Œç¡®ä¿ç¨‹åºåœ¨è¿è¡Œæ—¶ä¸å‘ç”Ÿæ•°æ®ç«äº‰ã€æ‚¬å‚æŒ‡é’ˆç­‰å†…å­˜å®‰å…¨é—®é¢˜ã€‚è®© Rust æ— éœ€åƒåœ¾å›æ”¶å™¨ï¼ˆgarbage collectorï¼‰å³å¯ä¿è¯å†…å­˜å®‰å…¨ã€‚

æ‰€æœ‰æƒä¸‰åŸåˆ™ï¼š

1. Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½è¢«ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ï¼Œè¯¥å˜é‡è¢«ç§°ä¸ºå€¼çš„æ‰€æœ‰è€…ï¼›

2.ä¸€ä¸ªå€¼åŒæ—¶åªèƒ½è¢«ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ï¼Œæˆ–è€…è¯´ä¸€ä¸ªå€¼åªèƒ½æ‹¥æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼›

3.å½“æ‰€æœ‰è€… (å˜é‡) ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢« drop (ä¸¢å¼ƒ)ã€‚

æˆ‘ä»¬åœ¨ä¸‹é¢çš„ä»£ç ä¸­å±•ç¤ºæ‰€æœ‰æƒçš„åˆ†é…ã€ä¿®æ”¹ã€‚

```rs
// å˜é‡ s1 æ‹¥æœ‰å­—ç¬¦ä¸² hello çš„æ‰€æœ‰æƒ
let mut s1:String = String::from("hello");

// å˜é‡ s1 å¯ä»¥ä¿®æ”¹è¯¥å­—ç¬¦ä¸²
s1.push_str(", hackquest."); // push_str() åœ¨å­—ç¬¦ä¸²åè¿½åŠ å­—é¢å€¼
```

æ‰€æœ‰æƒå¯ä»¥è½¬ç§»ç»™å‡½æ•°ï¼Œåœ¨ç§»åŠ¨æœŸé—´ï¼Œæ‰€æœ‰è€…çš„å †æ ˆå€¼å°†ä¼šè¢«å¤åˆ¶åˆ°å‡½æ•°è°ƒç”¨çš„å‚æ•°å †æ ˆä¸­ã€‚

```rs
struct Foo {
    x: i32,
}

fn do_something(f: Foo) {
    println!("{}", f.x);
    // f åœ¨è¿™é‡Œè¢« dropped é‡Šæ”¾
}

fn main() {
    let foo = Foo { x: 42 };
    // foo è¢«ç§»äº¤è‡³ do_something
    do_something(foo);
    // æ­¤å foo ä¾¿æ— æ³•å†è¢«ä½¿ç”¨
}
```

å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä»å‡½æ•°ä¸­è·å–æ‰€æœ‰æƒï¼š

```rs
// å‡½æ•°è¿”å›æ‰€æœ‰æƒ
fn create_string() -> String {
    let s = String::from("hello");
    s // è¿”å›æ‰€æœ‰æƒï¼Œs çš„æ‰€æœ‰æƒè½¬ç§»ç»™è°ƒç”¨è€…
}

fn main() {
    // ä»å‡½æ•°è·å–æ‰€æœ‰æƒ
    let s1 = create_string(); // s1 è·å¾—äº†ä»å‡½æ•°è¿”å›çš„å­—ç¬¦ä¸²çš„æ‰€æœ‰æƒ
    println!("ä»å‡½æ•°è·å–çš„å­—ç¬¦ä¸²ï¼š{}", s1);

    // å‡½æ•°ä¹Ÿå¯ä»¥è¿”å›ç»“æ„ä½“çš„æ‰€æœ‰æƒ
    let person = create_person();
    println!("ä»å‡½æ•°è·å–çš„äººï¼š{} å²", person.age);
}

struct Person {
    name: String,
    age: u32,
}

fn create_person() -> Person {
    Person {
        name: String::from("Ferris"),
        age: 25,
    } // è¿”å›ç»“æ„ä½“çš„æ‰€æœ‰æƒ
}
```

#### æ‰€æœ‰æƒè½¬ç§»çš„å®Œæ•´æµç¨‹

```rs
fn main() {
    // 1. åˆ›å»ºæ•°æ®å¹¶æ‹¥æœ‰æ‰€æœ‰æƒ
    let original = String::from("original data");

    // 2. å°†æ‰€æœ‰æƒè½¬ç§»ç»™å‡½æ•°
    let returned = take_and_return(original);

    // 3. é‡æ–°è·å¾—æ‰€æœ‰æƒ
    println!("é‡æ–°è·å¾—çš„æ•°æ®ï¼š{}", returned);

    // æ³¨æ„ï¼šoriginal åœ¨è¿™é‡Œå·²ç»ä¸èƒ½å†ä½¿ç”¨äº†
    // println!("{}", original); // ç¼–è¯‘é”™è¯¯ï¼šoriginal å·²ç»è¢«ç§»åŠ¨
}

fn take_and_return(s: String) -> String {
    println!("å‡½æ•°å†…éƒ¨æ¥æ”¶åˆ°çš„æ•°æ®ï¼š{}", s);
    s // è¿”å›æ‰€æœ‰æƒï¼Œè½¬ç§»ç»™è°ƒç”¨è€…
}
```

#### å‡½æ•°è¿”å›æ‰€æœ‰æƒçš„å¸¸è§åœºæ™¯

```rs
// åœºæ™¯ 1ï¼šå·¥å‚å‡½æ•° - åˆ›å»ºå¹¶è¿”å›æ–°å®ä¾‹
fn create_counter() -> Counter {
    Counter { count: 0 }
}

// åœºæ™¯ 2ï¼šè½¬æ¢å‡½æ•° - è½¬æ¢æ•°æ®å¹¶è¿”å›æ–°æ‰€æœ‰æƒ
fn process_string(s: String) -> String {
    let mut processed = s;
    processed.push_str(" (processed)");
    processed
}

// åœºæ™¯ 3ï¼šæ„å»ºå™¨æ¨¡å¼ - é€æ­¥æ„å»ºå¤æ‚å¯¹è±¡
fn build_person(name: String, age: u32) -> Person {
    Person { name, age }
}

struct Counter {
    count: u32,
}

fn main() {
    // ä½¿ç”¨å·¥å‚å‡½æ•°
    let counter = create_counter();

    // ä½¿ç”¨è½¬æ¢å‡½æ•°
    let original = String::from("hello");
    let processed = process_string(original);

    // ä½¿ç”¨æ„å»ºå™¨
    let person = build_person(String::from("Alice"), 30);

    println!("è®¡æ•°å™¨ï¼š{:?}", counter);
    println!("å¤„ç†åçš„å­—ç¬¦ä¸²ï¼š{}", processed);
    println!("æ„å»ºçš„äººï¼š{} å²", person.age);
}
```

# å€Ÿç”¨

å€Ÿç”¨ (Borrowing) ï¼šæ˜¯æŒ‡é€šè¿‡å¼•ç”¨æ¥è·å¾—æ•°æ®çš„è®¿é—®æƒï¼Œè€Œä¸æ˜¯æ‰€æœ‰æƒï¼Œç”¨ç¬¦å·&è¡¨ç¤ºã€‚å€Ÿç”¨ä½¿å¾—å¯ä»¥åœ¨ä¸è½¬ç§»æ‰€æœ‰æƒçš„æƒ…å†µä¸‹ï¼Œè®©å¤šä¸ªéƒ¨åˆ†åŒæ—¶è®¿é—®ç›¸åŒçš„æ•°æ®ã€‚Rust çš„å€Ÿç”¨åˆ†ä¸ºå¯å˜å€Ÿç”¨ï¼ˆmutable borrowingï¼‰å’Œä¸å¯å˜å€Ÿç”¨ï¼ˆimmutable borrowingï¼‰ä¸¤ç§å½¢å¼ã€‚

è§£å¼•ç”¨ï¼šæ˜¯å€Ÿç”¨çš„ä¸€ä¸ªé‡è¦æ“ä½œï¼Œå…è®¸é€šè¿‡å¼•ç”¨è·å–åˆ°è¢«å¼•ç”¨å€¼çš„å®é™…å†…å®¹ï¼Œç®€å•æ¥è¯´ï¼Œå°±æ˜¯è·å–åˆ°å€Ÿç”¨çš„å¯¹è±¡çš„å€¼ã€‚ç”¨ç¬¦å·\*è¡¨ç¤ºã€‚

## ä¸å¯å˜å€Ÿç”¨ï¼ˆImmutable Borrowingï¼‰

ä¸å¯å˜å€Ÿç”¨å…è®¸ä½ è¯»å–æ•°æ®ï¼Œä½†ä¸èƒ½ä¿®æ”¹å®ƒã€‚å¯ä»¥åŒæ—¶æœ‰å¤šä¸ªä¸å¯å˜å€Ÿç”¨ã€‚

```rs
fn main() {
    let s1 = String::from("hello");

    // ä¸å¯å˜å€Ÿç”¨ - ä½¿ç”¨ & ç¬¦å·
    let len = calculate_length(&s1);

    println!("'{}' çš„é•¿åº¦æ˜¯ {}", s1, len);

    // å¯ä»¥åŒæ—¶æœ‰å¤šä¸ªä¸å¯å˜å€Ÿç”¨
    let reference1 = &s1;
    let reference2 = &s1;
    let reference3 = &s1;

    println!("{} {} {}", reference1, reference2, reference3);

    // åŸå˜é‡ä»ç„¶å¯ä»¥ä½¿ç”¨
    println!("åŸå­—ç¬¦ä¸²ï¼š{}", s1);
}

fn calculate_length(s: &String) -> usize {
    s.len() // è¿™é‡Œåªæ˜¯è¯»å–å­—ç¬¦ä¸²é•¿åº¦ï¼Œä¸ä¿®æ”¹
}
```

## å¯å˜å€Ÿç”¨ï¼ˆMutable Borrowingï¼‰

å¯å˜å€Ÿç”¨å…è®¸ä½ è¯»å–å’Œä¿®æ”¹æ•°æ®ï¼Œä½†åŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å€Ÿç”¨ã€‚

```rs
fn main() {
    let mut s1 = String::from("hello");

    // å¯å˜å€Ÿç”¨ - ä½¿ç”¨ &mut ç¬¦å·
    change_string(&mut s1);

    println!("ä¿®æ”¹åçš„å­—ç¬¦ä¸²ï¼š{}", s1);

    // å¯å˜å€Ÿç”¨çš„é™åˆ¶ï¼šåŒä¸€æ—¶é—´åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å€Ÿç”¨
    let mut s2 = String::from("world");

    // ç¬¬ä¸€ä¸ªå¯å˜å€Ÿç”¨
    let ref1 = &mut s2;
    ref1.push_str("!"); // å¯ä»¥ä¿®æ”¹å­—ç¬¦ä¸²

    // å¯å˜å€Ÿç”¨æ—¢å¯ä»¥è¯»å–ä¹Ÿå¯ä»¥ä¿®æ”¹
    println!("ä¿®æ”¹åçš„å­—ç¬¦ä¸²ï¼š{}", ref1);

    // ä¸‹é¢çš„ä»£ç ä¼šç¼–è¯‘é”™è¯¯ï¼Œå› ä¸ºå·²ç»æœ‰å¯å˜å€Ÿç”¨äº†
    // let ref2 = &mut s2; // é”™è¯¯ï¼šä¸èƒ½åŒæ—¶æœ‰å¤šä¸ªå¯å˜å€Ÿç”¨
    // let ref3 = &s2;     // é”™è¯¯ï¼šä¸èƒ½åŒæ—¶æœ‰å¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨
}

fn change_string(s: &mut String) {
    s.push_str(", world!"); // ä¿®æ”¹å­—ç¬¦ä¸²
}

// æ›´è¯¦ç»†çš„ä¾‹å­å±•ç¤ºå¯å˜å€Ÿç”¨çš„èƒ½åŠ›
fn demonstrate_mutable_borrowing() {
    let mut text = String::from("Hello");

    println!("åŸå§‹å˜é‡ text: {}", text);

    // å¯å˜å€Ÿç”¨
    let mut_ref = &mut text;

    // å¯å˜å€Ÿç”¨å¯ä»¥è¯»å–æ•°æ®
    println!("é€šè¿‡å€Ÿç”¨è¯»å–ï¼š{}", mut_ref);

    // å¯å˜å€Ÿç”¨å¯ä»¥ä¿®æ”¹æ•°æ®
    mut_ref.push_str(" Rust!");
    println!("é€šè¿‡å€Ÿç”¨ä¿®æ”¹åï¼š{}", mut_ref);

    // å¯å˜å€Ÿç”¨è¿˜å¯ä»¥è°ƒç”¨ä¿®æ”¹æ–¹æ³•
    mut_ref.clear();
    mut_ref.push_str("New content");
    println!("é€šè¿‡å€Ÿç”¨æœ€ç»ˆå†…å®¹ï¼š{}", mut_ref);

    // å€Ÿç”¨ç»“æŸåï¼ŒåŸå§‹å˜é‡ä¹Ÿå‘ç”Ÿäº†å˜åŒ–
    println!("å€Ÿç”¨ç»“æŸåï¼ŒåŸå§‹å˜é‡ text: {}", text);
}

// å¦ä¸€ä¸ªä¾‹å­ï¼šå±•ç¤ºå¯å˜å€Ÿç”¨ç›´æ¥ä¿®æ”¹åŸå§‹æ•°æ®
fn show_original_data_change() {
    let mut numbers = vec![1, 2, 3];

    println!("åŸå§‹æ•°æ®ï¼š{:?}", numbers);

    {
        // åˆ›å»ºå¯å˜å€Ÿç”¨
        let mut_ref = &mut numbers;

        // é€šè¿‡å€Ÿç”¨ä¿®æ”¹æ•°æ®
        mut_ref.push(4);
        mut_ref[0] = 10;

        println!("å€Ÿç”¨æœŸé—´çš„æ•°æ®ï¼š{:?}", mut_ref);
    } // å€Ÿç”¨åœ¨è¿™é‡Œç»“æŸ

    // å€Ÿç”¨ç»“æŸåï¼ŒåŸå§‹æ•°æ®å·²ç»è¢«ä¿®æ”¹
    println!("å€Ÿç”¨ç»“æŸåçš„åŸå§‹æ•°æ®ï¼š{:?}", numbers);

    // å¯ä»¥ç»§ç»­ä½¿ç”¨åŸå§‹å˜é‡
    numbers.push(5);
    println!("ç»§ç»­ä½¿ç”¨åŸå§‹å˜é‡ï¼š{:?}", numbers);
}
```

## å€Ÿç”¨è§„åˆ™

Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨å¼ºåˆ¶æ‰§è¡Œä»¥ä¸‹è§„åˆ™ï¼š

```rs
fn main() {
    let mut data = vec![1, 2, 3, 4, 5];

    // è§„åˆ™ 1ï¼šåœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œè¦ä¹ˆåªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆåªèƒ½æœ‰ä»»æ„æ•°é‡çš„ä¸å¯å˜å¼•ç”¨
    let reference1 = &data;  // ä¸å¯å˜å€Ÿç”¨
    let reference2 = &data;  // ä¸å¯å˜å€Ÿç”¨
    let reference3 = &data;  // ä¸å¯å˜å€Ÿç”¨

    println!("{} {} {}", reference1[0], reference2[1], reference3[2]);

    // è§„åˆ™ 2ï¼šå¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ï¼ˆä¸èƒ½æœ‰æ‚¬å‚å¼•ç”¨ï¼‰
    // ä¸‹é¢çš„ä»£ç ä¼šç¼–è¯‘é”™è¯¯
    // let reference_to_nothing = dangle();

    // è§„åˆ™ 3ï¼šå¯å˜å€Ÿç”¨å’Œä¸å¯å˜å€Ÿç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨
    // ä¸‹é¢çš„ä»£ç ä¼šç¼–è¯‘é”™è¯¯
    // let mut_ref = &mut data;  // å¯å˜å€Ÿç”¨
    // println!("{}", reference1[0]); // é”™è¯¯ï¼šåŒæ—¶å­˜åœ¨å¯å˜å’Œä¸å¯å˜å€Ÿç”¨
}

// è¿™ä¸ªå‡½æ•°ä¼šäº§ç”Ÿæ‚¬å‚å¼•ç”¨ï¼Œç¼–è¯‘ä¼šå¤±è´¥
// fn dangle() -> &String {
//     let s = String::from("hello");
//     &s // è¿”å›å¯¹å±€éƒ¨å˜é‡çš„å¼•ç”¨ï¼Œs åœ¨å‡½æ•°ç»“æŸæ—¶ä¼šè¢«ä¸¢å¼ƒ
// }
```

## å€Ÿç”¨åœ¨ä¸åŒåœºæ™¯ä¸­çš„åº”ç”¨

### 1. å‡½æ•°å‚æ•°ä¸­çš„å€Ÿç”¨

```rs
fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];

    // ä¸å¯å˜å€Ÿç”¨ä½œä¸ºå‚æ•°
    print_vector(&numbers);

    // å¯å˜å€Ÿç”¨ä½œä¸ºå‚æ•°
    add_element(&mut numbers, 6);

    print_vector(&numbers);
}

fn print_vector(v: &Vec<i32>) {
    println!("å‘é‡å†…å®¹ï¼š{:?}", v);
}

fn add_element(v: &mut Vec<i32>, element: i32) {
    v.push(element);
}
```

### 2. ç»“æ„ä½“ä¸­çš„å€Ÿç”¨

```rs
struct Book {
    title: String,
    author: String,
    year: u32,
}

fn main() {
    let mut book = Book {
        title: String::from("Rust Programming"),
        author: String::from("Ferris"),
        year: 2023,
    };

    // ä¸å¯å˜å€Ÿç”¨
    print_book_info(&book);

    // å¯å˜å€Ÿç”¨
    update_book_year(&mut book, 2024);

    print_book_info(&book);
}

fn print_book_info(book: &Book) {
    println!("ä¹¦åï¼š{}, ä½œè€…ï¼š{}, å¹´ä»½ï¼š{}", book.title, book.author, book.year);
}

fn update_book_year(book: &mut Book, new_year: u32) {
    book.year = new_year;
}
```

### 3. åˆ‡ç‰‡å€Ÿç”¨

```rs
fn main() {
    let mut numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    // ä¸å¯å˜åˆ‡ç‰‡å€Ÿç”¨
    let first_half = &numbers[0..5];
    let second_half = &numbers[5..10];

    println!("å‰åŠéƒ¨åˆ†ï¼š{:?}", first_half);
    println!("ååŠéƒ¨åˆ†ï¼š{:?}", second_half);

    // å¯å˜åˆ‡ç‰‡å€Ÿç”¨
    let mutable_slice = &mut numbers[2..7];
    for num in mutable_slice.iter_mut() {
        *num *= 2; // è§£å¼•ç”¨å¹¶ä¿®æ”¹å€¼
    }

    println!("ä¿®æ”¹åçš„æ•°ç»„ï¼š{:?}", numbers);
}
```

### 4. å€Ÿç”¨æ£€æŸ¥å™¨çš„æ™ºèƒ½åˆ†æ

```rs
fn main() {
    let mut data = vec![1, 2, 3, 4, 5];

    // å€Ÿç”¨æ£€æŸ¥å™¨èƒ½å¤Ÿåˆ†æä½œç”¨åŸŸï¼Œå…è®¸è¿™æ ·çš„ä»£ç 
    {
        let reference = &data; // ä¸å¯å˜å€Ÿç”¨
        println!("é•¿åº¦ï¼š{}", reference.len());
    } // reference åœ¨è¿™é‡Œç¦»å¼€ä½œç”¨åŸŸ

    // ç°åœ¨å¯ä»¥åˆ›å»ºå¯å˜å€Ÿç”¨
    let mutable_ref = &mut data;
    mutable_ref.push(6);

    println!("ä¿®æ”¹åçš„æ•°æ®ï¼š{:?}", data);
}
```

## è§£å¼•ç”¨æ“ä½œ

è§£å¼•ç”¨æ“ä½œä½¿ç”¨ `*` ç¬¦å·ï¼Œå®ƒå…è®¸æˆ‘ä»¬é€šè¿‡å¼•ç”¨è·å–è¢«å¼•ç”¨å€¼çš„å®é™…å†…å®¹ã€‚è™½ç„¶å¯å˜å€Ÿç”¨å¯ä»¥ç›´æ¥ä¿®æ”¹åŸå§‹æ•°æ®ï¼Œä½†è§£å¼•ç”¨åœ¨æŸäº›åœºæ™¯ä¸‹æ˜¯å¿…è¦çš„ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦è§£å¼•ç”¨

```rs
fn main() {
    let mut x = 5;
    let y = &mut x; // å¯å˜å€Ÿç”¨

    // æƒ…å†µ 1ï¼šç®—æœ¯è¿ç®—éœ€è¦è§£å¼•ç”¨
    *y += 1; // é€šè¿‡è§£å¼•ç”¨è¿›è¡Œç®—æœ¯è¿ç®—
    *y = *y * 2; // é€šè¿‡è§£å¼•ç”¨è¿›è¡Œä¹˜æ³•è¿ç®—

    // æƒ…å†µ 2ï¼šæ¯”è¾ƒæ“ä½œéœ€è¦è§£å¼•ç”¨
    if *y > 10 {
        println!("y å¤§äº 10");
    }

    // æƒ…å†µ 3ï¼šå‡½æ•°è°ƒç”¨å¯èƒ½éœ€è¦è§£å¼•ç”¨
    let result = some_function(*y); // ä¼ é€’å€¼è€Œä¸æ˜¯å¼•ç”¨

    println!("x = {}", x); // è¾“å‡ºï¼šx = 12
}

fn some_function(value: i32) -> i32 {
    value * 2
}
```

### å¯å˜å€Ÿç”¨ä¸ç®—æœ¯è¿ç®—çš„å…³ç³»

```rs
fn main() {
    let mut x = 5;
    let y = &mut x; // å¯å˜å€Ÿç”¨

    // é”™è¯¯ï¼šä¸èƒ½ç›´æ¥å¯¹å¼•ç”¨è¿›è¡Œç®—æœ¯è¿ç®—
    // y += 1; // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½å¯¹ &mut i32 è¿›è¡Œ += æ“ä½œ

    // æ­£ç¡®ï¼šé€šè¿‡è§£å¼•ç”¨è¿›è¡Œç®—æœ¯è¿ç®—
    *y += 1; // è§£å¼•ç”¨åå¾—åˆ° i32ï¼Œå¯ä»¥è¿›è¡Œç®—æœ¯è¿ç®—

    // é”™è¯¯ï¼šä¸èƒ½ç›´æ¥æ¯”è¾ƒå¼•ç”¨
    // if y > 10 { } // ç¼–è¯‘é”™è¯¯ï¼šä¸èƒ½æ¯”è¾ƒ &mut i32 å’Œ i32

    // æ­£ç¡®ï¼šé€šè¿‡è§£å¼•ç”¨è¿›è¡Œæ¯”è¾ƒ
    if *y > 10 {
        println!("y å¤§äº 10");
    }

    println!("x = {}", x);
}
```

### è§£å¼•ç”¨ vs å¯å˜å€Ÿç”¨ç›´æ¥ä¿®æ”¹

```rs
fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];

    // æ–¹æ³• 1ï¼šä½¿ç”¨å¯å˜å€Ÿç”¨çš„æ–¹æ³•ç›´æ¥ä¿®æ”¹
    let mut_ref = &mut numbers;
    mut_ref.push(6); // ç›´æ¥è°ƒç”¨æ–¹æ³•ï¼Œä¸éœ€è¦è§£å¼•ç”¨
    mut_ref[0] = 10; // ç›´æ¥ç´¢å¼•è®¿é—®ï¼Œä¸éœ€è¦è§£å¼•ç”¨

    // æ–¹æ³• 2ï¼šä½¿ç”¨è§£å¼•ç”¨è¿›è¡Œå¤æ‚æ“ä½œ
    let mut_ref = &mut numbers;
    *&mut mut_ref[1] = 20; // è§£å¼•ç”¨è¿›è¡Œèµ‹å€¼
    *&mut mut_ref[2] += 5; // è§£å¼•ç”¨è¿›è¡Œç®—æœ¯è¿ç®—

    println!("numbers: {:?}", numbers);
}
```

### è§£å¼•ç”¨çš„ä¸åŒåœºæ™¯

```rs
fn main() {
    let mut value = 42;
    let ref_value = &mut value;

    // åœºæ™¯ 1ï¼šç®—æœ¯è¿ç®—
    *ref_value += 8;
    *ref_value *= 2;
    *ref_value -= 10;

    // åœºæ™¯ 2ï¼šæ¯”è¾ƒæ“ä½œ
    if *ref_value > 50 {
        println!("å€¼å¤§äº 50");
    }

    // åœºæ™¯ 3ï¼šå‡½æ•°å‚æ•°ä¼ é€’
    let result = calculate_square(*ref_value);

    // åœºæ™¯ 4ï¼šæ¨¡å¼åŒ¹é…
    match *ref_value {
        0..=50 => println!("å€¼åœ¨ 0-50 ä¹‹é—´"),
        51..=100 => println!("å€¼åœ¨ 51-100 ä¹‹é—´"),
        _ => println!("å€¼å¤§äº 100"),
    }

    println!("æœ€ç»ˆå€¼ï¼š{}", value);
}

fn calculate_square(x: i32) -> i32 {
    x * x
}
```

### è§£å¼•ç”¨åœ¨è¿­ä»£å™¨ä¸­çš„åº”ç”¨

```rs
fn main() {
    let mut numbers = vec![1, 2, 3, 4, 5];

    // ä½¿ç”¨ iter_mut() è·å–å¯å˜å¼•ç”¨è¿­ä»£å™¨
    for num in numbers.iter_mut() {
        *num *= 2; // å¿…é¡»è§£å¼•ç”¨æ‰èƒ½ä¿®æ”¹å€¼
    }

    println!("ä¿®æ”¹åçš„æ•°å­—ï¼š{:?}", numbers);

    // ä½¿ç”¨ enumerate() è·å–ç´¢å¼•å’Œå¯å˜å¼•ç”¨
    for (index, num) in numbers.iter_mut().enumerate() {
        *num += index as i32; // è§£å¼•ç”¨è¿›è¡Œç®—æœ¯è¿ç®—
    }

    println!("æœ€ç»ˆæ•°å­—ï¼š{:?}", numbers);
}
```

### è§£å¼•ç”¨åœ¨ç»“æ„ä½“ä¸­çš„åº”ç”¨

```rs
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 10, y: 20 };
    let point_ref = &mut point;

    // è®¿é—®ç»“æ„ä½“å­—æ®µæ—¶ä¸éœ€è¦è§£å¼•ç”¨
    point_ref.x = 15;
    point_ref.y = 25;

    // ä½†è¿›è¡Œç®—æœ¯è¿ç®—æ—¶éœ€è¦è§£å¼•ç”¨
    let x_ref = &mut point_ref.x;
    *x_ref += 5;

    let y_ref = &mut point_ref.y;
    *y_ref *= 2;

    println!("ç‚¹åæ ‡ï¼š({}, {})", point.x, point.y);
}
```

### è§£å¼•ç”¨çš„å¿…è¦æ€§æ€»ç»“

1. **ç®—æœ¯è¿ç®—**ï¼š`*ref += 1`ã€`*ref * 2` ç­‰æ“ä½œå¿…é¡»è§£å¼•ç”¨ï¼ˆå› ä¸ºç®—æœ¯è¿ç®—ç¬¦éœ€è¦å€¼ç±»å‹ï¼‰
2. **æ¯”è¾ƒæ“ä½œ**ï¼š`*ref > 10`ã€`*ref == 5` ç­‰æ¯”è¾ƒå¿…é¡»è§£å¼•ç”¨ï¼ˆå› ä¸ºæ¯”è¾ƒè¿ç®—ç¬¦éœ€è¦å€¼ç±»å‹ï¼‰
3. **å‡½æ•°å‚æ•°**ï¼šä¼ é€’å€¼è€Œä¸æ˜¯å¼•ç”¨æ—¶éœ€è¦è§£å¼•ç”¨
4. **æ¨¡å¼åŒ¹é…**ï¼šåœ¨ match è¯­å¥ä¸­ä½¿ç”¨å€¼éœ€è¦è§£å¼•ç”¨
5. **è¿­ä»£å™¨æ“ä½œ**ï¼š`for num in iter_mut()` ä¸­ä¿®æ”¹å€¼éœ€è¦è§£å¼•ç”¨
6. **å¤æ‚è¡¨è¾¾å¼**ï¼šåœ¨å¤æ‚è¡¨è¾¾å¼ä¸­ä½¿ç”¨å€¼æ—¶éœ€è¦è§£å¼•ç”¨

### ç±»å‹ç³»ç»Ÿè§’åº¦ç†è§£è§£å¼•ç”¨

```rs
fn main() {
    let mut x = 5;
    let y = &mut x; // y çš„ç±»å‹æ˜¯ &mut i32

    // ç®—æœ¯è¿ç®—ç¬¦ï¼ˆå¦‚ +=ï¼‰æ˜¯ä¸º i32 ç±»å‹å®šä¹‰çš„ï¼Œä¸æ˜¯ä¸º &mut i32 å®šä¹‰çš„
    // æ‰€ä»¥éœ€è¦è§£å¼•ç”¨å°† &mut i32 è½¬æ¢ä¸º i32

    // é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
    // y += 1; // ç±»å‹ï¼š&mut i32 += i32ï¼ˆä¸åŒ¹é…ï¼‰

    // æ­£ç¡®ï¼šè§£å¼•ç”¨åç±»å‹åŒ¹é…
    *y += 1; // ç±»å‹ï¼ši32 += i32ï¼ˆåŒ¹é…ï¼‰

    // åŒæ ·ï¼Œæ¯”è¾ƒè¿ç®—ç¬¦ä¹Ÿæ˜¯ä¸ºå€¼ç±»å‹å®šä¹‰çš„
    // if y > 10 { } // ç±»å‹ï¼š&mut i32 > i32ï¼ˆä¸åŒ¹é…ï¼‰
    if *y > 10 { } // ç±»å‹ï¼ši32 > i32ï¼ˆåŒ¹é…ï¼‰
}
```

### è‡ªåŠ¨è§£å¼•ç”¨

Rust åœ¨æŸäº›æƒ…å†µä¸‹ä¼šè‡ªåŠ¨è§£å¼•ç”¨ï¼š

```rs
fn main() {
    let x = 5;
    let ref_x = &x;

    // è‡ªåŠ¨è§£å¼•ç”¨
    println!("x = {}", ref_x); // ç­‰åŒäº println!("x = {}", *ref_x);

    // æ–¹æ³•è°ƒç”¨æ—¶çš„è‡ªåŠ¨è§£å¼•ç”¨
    let text = String::from("hello");
    let ref_text = &text;
    println!("é•¿åº¦ï¼š{}", ref_text.len()); // è‡ªåŠ¨è§£å¼•ç”¨è°ƒç”¨æ–¹æ³•
}
```

è§£å¼•ç”¨æ˜¯ Rust ä¸­å¤„ç†å¼•ç”¨çš„é‡è¦æ“ä½œï¼Œå®ƒè®©æˆ‘ä»¬èƒ½å¤Ÿï¼š

- è·å–è¢«å¼•ç”¨å€¼çš„å®é™…å†…å®¹
- è¿›è¡Œç®—æœ¯è¿ç®—å’Œæ¯”è¾ƒæ“ä½œ
- åœ¨éœ€è¦å€¼çš„åœºæ™¯ä¸­ä½¿ç”¨å¼•ç”¨
- åœ¨è¿­ä»£å™¨ä¸­ä¿®æ”¹é›†åˆå…ƒç´ 

å€Ÿç”¨æ˜¯ Rust å†…å­˜å®‰å…¨çš„æ ¸å¿ƒæœºåˆ¶ä¹‹ä¸€ï¼Œå®ƒé€šè¿‡ç¼–è¯‘æ—¶æ£€æŸ¥ç¡®ä¿ç¨‹åºä¸ä¼šå‡ºç°æ•°æ®ç«äº‰å’Œæ‚¬å‚å¼•ç”¨ç­‰å†…å­˜å®‰å…¨é—®é¢˜ã€‚

é€šè¿‡ä¸€ä¸‹çš„å›¾ç¤ºï¼Œæˆ‘ä»¬ä¼šå‘ç°å€Ÿç”¨å…¶å®å°±æ˜¯å­˜å‚¨äº†å­—ç¬¦ä¸²å¯¹è±¡çš„å†…å­˜åœ°å€æŒ‡é’ˆï¼Œæ‰€ä»¥ç”¨æ›´å®½æ³›çš„æ¦‚å¿µæ¥è¯´ï¼Œå€Ÿç”¨ä¹Ÿæ˜¯ä¸€ç§å¼•ç”¨ã€‚

![](./assets/rust-borrow.webp)

# ç”Ÿå‘½å‘¨æœŸ

Rust ä¸­çš„æ¯ä¸€ä¸ªå¼•ç”¨éƒ½æœ‰å…¶ç”Ÿå‘½å‘¨æœŸï¼ˆlifetimeï¼‰ï¼Œä¹Ÿå°±æ˜¯å¼•ç”¨ä¿æŒæœ‰æ•ˆçš„ä½œç”¨åŸŸã€‚åœ¨å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬æ— éœ€æ‰‹åŠ¨çš„å£°æ˜ç”Ÿå‘½å‘¨æœŸï¼Œå› ä¸ºç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨è¿›è¡Œæ¨å¯¼ï¼Œä½†å½“å¤šä¸ªç”Ÿå‘½å‘¨æœŸå­˜åœ¨ï¼Œå¦‚åŒä¸ŠèŠ‚çš„ longest å‡½æ•°ï¼šfn longest(x: &str, y: &str) -> &str {â€¦â€¦}ï¼Œå…¥å‚æœ‰ 2 ä¸ªä¸åŒå¼•ç”¨ï¼Œå‡ºå‚ä¹Ÿä¼šæ ¹æ®å‡½æ•°ä½“é€»è¾‘æŒ‡å‘ä¸åŒçš„å¼•ç”¨ï¼Œæ­¤æ—¶ç¼–è¯‘å™¨æ— æ³•è¿›è¡Œå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸåˆ†æï¼Œå°±éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨æ ‡æ˜ä¸åŒå¼•ç”¨ä¹‹é—´çš„ç”Ÿå‘½å‘¨æœŸå…³ç³»ï¼Œä¹Ÿå°±æ˜¯ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ã€‚

ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å¹¶ä¸æ”¹å˜ä»»ä½•å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸçš„é•¿çŸ­ã€‚å®ƒåªæ˜¯æè¿°äº†å¤šä¸ªå¼•ç”¨ç”Ÿå‘½å‘¨æœŸç›¸äº’çš„å…³ç³»ï¼Œä¾¿äºç¼–è¯‘å™¨è¿›è¡Œå¼•ç”¨çš„åˆ†æï¼Œä½†ä¸å½±å“å…¶ç”Ÿå‘½å‘¨æœŸã€‚å®ƒçš„ç›®çš„æ˜¯é¿å…æ‚¬å‚å¼•ç”¨ï¼Œé˜²æ­¢ç¨‹åºå¼•ç”¨äº†æœ¬ä¸è¯¥å¼•ç”¨çš„æ•°æ®ã€‚

ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨çš„è¯­æ³•ï¼šç”Ÿå‘½å‘¨æœŸå‚æ•°åç§°å¿…é¡»ä»¥æ’‡å·'å¼€å¤´ï¼Œå…¶åç§°é€šå¸¸å…¨æ˜¯å°å†™ï¼Œç±»ä¼¼äºæ³›å‹å…¶åç§°éå¸¸çŸ­ã€‚'a æ˜¯é»˜è®¤ä½¿ç”¨çš„åç§°ã€‚ç”Ÿå‘½å‘¨æœŸå‚æ•°æ ‡æ³¨ä½äºå¼•ç”¨çš„ & ä¹‹åï¼Œå¹¶æœ‰ä¸€ä¸ªç©ºæ ¼æ¥å°†å¼•ç”¨ç±»å‹ä¸ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨åˆ†éš”å¼€ã€‚

å¯¹äºå‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ä¸­å­˜åœ¨å¤šä¸ªå¼•ç”¨ï¼Œéœ€è¦æ‰‹åŠ¨å»æ ‡è®°ç”Ÿå‘½å‘¨æœŸã€‚

```rs
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

å‚æ•° x å’Œ y çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨éƒ½æ˜¯'aï¼Œè‡³äº 'a ç©¶ç«Ÿæ˜¯å¤šä¹…æˆ‘ä»¬å¹¶ä¸éœ€è¦å…³å¿ƒï¼Œåªéœ€è¦çŸ¥é“ 'a ä»£è¡¨çš„æ˜¯å˜é‡ x å’Œ y ç”Ÿå‘½å‘¨æœŸç›¸åŒï¼ˆé‡å ï¼‰çš„é‚£éƒ¨åˆ†ï¼Œå³ x å’Œ y ç”Ÿå‘½å‘¨æœŸä¸­æœ€å°çš„é‚£ä¸ªèŒƒå›´ã€‚è€Œè¿”å›å€¼ä¹Ÿæ˜¯é€šè¿‡ 'a è¿›è¡Œæ ‡æ³¨çš„ï¼Œè¯´æ˜äº†è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸å˜é‡ x æˆ– y ä¸­æœ€å°çš„é‚£ä¸ªä¸€è‡´ã€‚æˆ‘ä»¬é€šè¿‡ FAQ æ¥çœ‹ä¸‹å…·ä½“çš„ä½¿ç”¨ä¾‹å­ã€‚

longest å‡½æ•°æ˜¯å¦‚ä½•å¤„ç†å…·æœ‰ä¸åŒç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨ï¼Ÿ

å¦‚ä¸‹çš„ä»£ç å±•ç¤ºäº† string1 å’Œ string2 è¿™ä¸¤ä¸ªä¸åŒç”Ÿå‘½å‘¨æœŸçš„å˜é‡ï¼Œå‰è€…çš„ç”Ÿå‘½å‘¨æœŸä½äºå¤–éƒ¨çš„{}ä¸­ï¼Œè€Œåè€…çš„ç”Ÿå‘½å‘¨æœŸä½äºå†…éƒ¨çš„{}ä¸­ï¼Œæ‰€ä»¥'a ä»£è¡¨çš„ç”Ÿå‘½å‘¨æœŸèŒƒå›´æ˜¯ä¸¤è€…ä¸­è¾ƒå°çš„é‚£ä¸ªï¼Œå³å†…éƒ¨çš„ {}ï¼Œæ­¤æ—¶è¿”å›å€¼ result çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯å±äºå†…éƒ¨çš„ {}ï¼Œå³è¿”å›å€¼èƒ½å¤Ÿä¿è¯åœ¨ string1 å’Œ string2 ä¸­è¾ƒçŸ­çš„é‚£ä¸ªç”Ÿå‘½å‘¨æœŸç»“æŸå‰æœ‰æ•ˆï¼Œæ­¤æ—¶ä¸ä¼šå‘ç”Ÿæ‚¬å‚å¼•ç”¨ï¼Œç¼–è¯‘é€šè¿‡ã€‚

```rs
fn main() {
    let string1 = String::from("abcdefghijklmnopqrstuvwxyz");
    {
        let string2 = String::from("123456789");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}
```

æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬å°è¯•å¦å¤–ä¸€ä¸ªä¾‹å­ï¼Œè¯¥ä¾‹å­æ­ç¤ºäº† result çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»æ˜¯ä¸¤ä¸ªå‚æ•°ä¸­è¾ƒçŸ­çš„é‚£ä¸ªã€‚

```rs
fn main() {
    let string1 = String::from("abcdefghijklmnopqrstuvwxyz");
    let result;
    {
        let string2 = String::from("123456789");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result);
}
```

æ­¤æ—¶ 'a ä»£è¡¨çš„ç”Ÿå‘½å‘¨æœŸèŒƒå›´ä¾æ—§æ˜¯å˜é‡ string1 å’Œ string2 ä¸­æœ€å°çš„é‚£ä¸ªï¼Œå³å†…éƒ¨çš„{}ï¼Œä½†è¿”å›å€¼ result çš„ç”Ÿå‘½å‘¨æœŸèŒƒå›´å´æ˜¯å¤–éƒ¨çš„{}ï¼Œè€Œä¸æ˜¯å†…éƒ¨çš„{}ï¼Œä¹Ÿå°±æ„å‘³ç€ result å¯èƒ½ä¼šå¼•ç”¨ä¸€ä¸ªæ— æ•ˆçš„å€¼ï¼Œå› æ­¤ç¼–è¯‘å¤±è´¥ã€‚

> æ³¨æ„ï¼šé€šè¿‡äººä¸ºè§‚å¯Ÿ result çš„å¼•ç”¨åº”è¯¥ä¸º string1ï¼Œè¿™æ ·è¿”å›å€¼ result å’Œ string1 çš„ä½œç”¨åŸŸæ˜¯ä¸€è‡´çš„ï¼Œç†è®ºä¸Šæ˜¯åº”è¯¥ç¼–è¯‘é€šè¿‡çš„ã€‚ä½†æ˜¯ï¼ŒRust çš„ç¼–è¯‘å™¨ä¼šé‡‡ç”¨ä¿å®ˆçš„ç­–ç•¥ï¼Œæˆ‘ä»¬é€šè¿‡ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨å‘Šè¯‰ Rustï¼Œlongest å‡½æ•°è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ä¼ å…¥å‚æ•°ä¸­è¾ƒå°çš„é‚£ä¸ªå˜é‡çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› æ­¤å€Ÿç”¨æ£€æŸ¥å™¨ä¸å…è®¸ä¸Šè¿°ä»£ç ï¼Œå› ä¸ºå¯èƒ½å­˜åœ¨æ— æ•ˆå¼•ç”¨ã€‚

## ç”Ÿå‘½å‘¨æœŸæ³¨è§£

ç”Ÿå‘½å‘¨æœŸæ³¨è§£æ˜¯ Rust ç”¨æ¥ç¡®ä¿å¼•ç”¨æœ‰æ•ˆæ€§çš„é‡è¦æœºåˆ¶ã€‚å®ƒå‘Šè¯‰ç¼–è¯‘å™¨å¼•ç”¨åº”è¯¥ä¿æŒæœ‰æ•ˆå¤šé•¿æ—¶é—´ã€‚

#### ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„è¯­æ³•

ç”Ÿå‘½å‘¨æœŸæ³¨è§£ä½¿ç”¨ `'a`ã€`'b` ç­‰æ ‡è¯†ç¬¦ï¼Œå…¶ä¸­ `'a` æ˜¯æœ€å¸¸ç”¨çš„ã€‚

```rs
// åŸºæœ¬è¯­æ³•ï¼š<'a> å£°æ˜ç”Ÿå‘½å‘¨æœŸå‚æ•°
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

#### ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„å«ä¹‰

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼š

- `<'a>` å£°æ˜äº†ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•° `'a`
- `x: &'a str` è¡¨ç¤ºå‚æ•° `x` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `'a`
- `y: &'a str` è¡¨ç¤ºå‚æ•° `y` çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯ `'a`
- `-> &'a str` è¡¨ç¤ºè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¹Ÿæ˜¯ `'a`

è¿™æ„å‘³ç€ï¼š**è¿”å›çš„å¼•ç”¨å¿…é¡»ä¸è¾“å…¥å‚æ•°ä¸­ç”Ÿå‘½å‘¨æœŸè¾ƒçŸ­çš„é‚£ä¸ªä¿æŒä¸€è‡´**ã€‚

#### è¯¦ç»†è§£é‡Šç”Ÿå‘½å‘¨æœŸæ³¨è§£

```rs
fn main() {
    let string1 = String::from("abcd");     // ç”Ÿå‘½å‘¨æœŸå¼€å§‹
    let string2 = "xyz";                    // ç”Ÿå‘½å‘¨æœŸå¼€å§‹

    let result = longest(&string1, string2); // è°ƒç”¨å‡½æ•°
    println!("æœ€é•¿çš„å­—ç¬¦ä¸²æ˜¯ {}", result);

    // è¿™é‡Œ string1 å’Œ string2 ä»ç„¶æœ‰æ•ˆï¼Œæ‰€ä»¥ result ä¹Ÿæœ‰æ•ˆ
} // ç”Ÿå‘½å‘¨æœŸç»“æŸ

// ç”Ÿå‘½å‘¨æœŸæ³¨è§£å‘Šè¯‰ç¼–è¯‘å™¨ï¼š
// 1. å‚æ•° x å’Œ y å¿…é¡»è‡³å°‘ä¸è¿”å›å€¼ä¸€æ ·é•¿
// 2. è¿”å›å€¼ä¸èƒ½æ¯”ä»»ä½•ä¸€ä¸ªå‚æ•°æ´»å¾—æ›´ä¹…
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x  // è¿”å› x çš„å¼•ç”¨
    } else {
        y  // è¿”å› y çš„å¼•ç”¨
    }
}
```

#### ä¸ºä»€ä¹ˆéœ€è¦ç”Ÿå‘½å‘¨æœŸæ³¨è§£

```rs
// æ²¡æœ‰ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„å‡½æ•°ï¼ˆç¼–è¯‘é”™è¯¯ï¼‰
fn longest_without_lifetime(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
    // ç¼–è¯‘å™¨ä¸çŸ¥é“è¿”å›çš„å¼•ç”¨åº”è¯¥ä¸å“ªä¸ªå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸä¸€è‡´
}

// æœ‰ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„å‡½æ•°ï¼ˆæ­£ç¡®ï¼‰
fn longest_with_lifetime<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
    // ç¼–è¯‘å™¨çŸ¥é“è¿”å›çš„å¼•ç”¨ä¸è¾“å…¥å‚æ•°æœ‰ç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ
}
```

#### ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„å®é™…åº”ç”¨

```rs
// ä¾‹å­ 1ï¼šç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
struct ImportantExcerpt<'a> {
    part: &'a str, // è¿™ä¸ªå¼•ç”¨å¿…é¡»è‡³å°‘ä¸ç»“æ„ä½“å®ä¾‹ä¸€æ ·é•¿
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().unwrap();

    let i = ImportantExcerpt {
        part: first_sentence,
    };

    // i çš„ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡ novel
    println!("é‡è¦ç‰‡æ®µï¼š{}", i.part);
}

// ä¾‹å­ 2ï¼šå¤šä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°
fn longest_with_different_lifetimes<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {
    // è¿™ä¸ªå‡½æ•°æ€»æ˜¯è¿”å› xï¼Œæ‰€ä»¥è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ x ç›¸åŒ
    x
}

// ä¾‹å­ 3ï¼šç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™
fn first_word(s: &str) -> &str {
    // ç¼–è¯‘å™¨å¯ä»¥è‡ªåŠ¨æ¨æ–­ç”Ÿå‘½å‘¨æœŸï¼Œä¸éœ€è¦æ˜¾å¼æ³¨è§£
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

#### ç”Ÿå‘½å‘¨æœŸçœç•¥è§„åˆ™

Rust ç¼–è¯‘å™¨æœ‰ä¸€äº›è§„åˆ™å¯ä»¥è‡ªåŠ¨æ¨æ–­ç”Ÿå‘½å‘¨æœŸï¼Œä¸éœ€è¦æ˜¾å¼æ³¨è§£ï¼š

1. **æ¯ä¸ªå¼•ç”¨å‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°**
2. **å¦‚æœåªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œé‚£ä¹ˆå®ƒè¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°**
3. **å¦‚æœæœ‰å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†å…¶ä¸­ä¸€ä¸ªæ˜¯ `&self` æˆ– `&mut self`ï¼Œé‚£ä¹ˆ `self` çš„ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰è¾“å‡ºç”Ÿå‘½å‘¨æœŸå‚æ•°**

```rs
// è§„åˆ™ 1ï¼šæ¯ä¸ªå‚æ•°éƒ½æœ‰è‡ªå·±çš„ç”Ÿå‘½å‘¨æœŸ
fn foo<'a, 'b>(x: &'a i32, y: &'b i32) {}

// è§„åˆ™ 2ï¼šåªæœ‰ä¸€ä¸ªè¾“å…¥å‚æ•°æ—¶
fn bar<'a>(x: &'a i32) -> &'a i32 { x }

// è§„åˆ™ 3ï¼šæ–¹æ³•ä¸­çš„ self å‚æ•°
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("æ³¨æ„ï¼š{}", announcement);
        self.part
    }
}
```

#### ä»€ä¹ˆæ˜¯ self å‚æ•°

`self` å‚æ•°æ˜¯ Rust ä¸­æ–¹æ³•ï¼ˆmethodï¼‰çš„ç‰¹æ®Šå‚æ•°ï¼Œå®ƒè¡¨ç¤ºæ–¹æ³•è¢«è°ƒç”¨çš„å®ä¾‹ã€‚`self` å‚æ•°è®©æ–¹æ³•èƒ½å¤Ÿè®¿é—®ç»“æ„ä½“å®ä¾‹çš„æ•°æ®ã€‚

#### self å‚æ•°çš„ä½¿ç”¨åœºæ™¯

`self` å‚æ•°ä¸»è¦åœ¨ä»¥ä¸‹åœºæ™¯ä¸­ä½¿ç”¨ï¼š

1. **ç»“æ„ä½“æ–¹æ³•**ï¼šåœ¨ `impl` å—ä¸­å®šä¹‰çš„æ–¹æ³•
2. **æšä¸¾æ–¹æ³•**ï¼šåœ¨æšä¸¾çš„ `impl` å—ä¸­å®šä¹‰çš„æ–¹æ³•
3. **ç‰¹å¾æ–¹æ³•**ï¼šåœ¨ç‰¹å¾ï¼ˆtraitï¼‰ä¸­å®šä¹‰çš„æ–¹æ³•
4. **æ‰©å±•æ–¹æ³•**ï¼šä¸ºç°æœ‰ç±»å‹æ·»åŠ æ–°æ–¹æ³•

#### self å‚æ•°çš„ä¸åŒå½¢å¼

```rs
struct Person {
    name: String,
    age: u32,
}

impl Person {
    // 1. &self - ä¸å¯å˜å€Ÿç”¨ï¼Œåªè¯»è®¿é—®
    fn get_name(&self) -> &str {
        &self.name
    }

    // 2. &mut self - å¯å˜å€Ÿç”¨ï¼Œå¯ä»¥ä¿®æ”¹å®ä¾‹
    fn have_birthday(&mut self) {
        self.age += 1;
        println!("{} ç°åœ¨ {} å²äº†ï¼", self.name, self.age);
    }

    // 3. self - è·å–æ‰€æœ‰æƒï¼Œæ¶ˆè€—å®ä¾‹
    fn consume(self) -> String {
        format!("{} è¢«æ¶ˆè€—äº†", self.name)
    }
}

fn main() {
    let mut person = Person {
        name: String::from("Ferris"),
        age: 25,
    };

    // ä½¿ç”¨ &self æ–¹æ³•
    println!("å§“åï¼š{}", person.get_name());

    // ä½¿ç”¨ &mut self æ–¹æ³•
    person.have_birthday();

    // ä½¿ç”¨ self æ–¹æ³•ï¼ˆæ³¨æ„ï¼šè¿™ä¼šæ¶ˆè€— personï¼‰
    let message = person.consume();
    println!("{}", message);

    // è¿™é‡Œä¸èƒ½å†ä½¿ç”¨ personï¼Œå› ä¸ºå®ƒå·²ç»è¢«æ¶ˆè€—äº†
    // println!("{}", person.name); // ç¼–è¯‘é”™è¯¯
}
```

#### self å‚æ•°åœ¨ç”Ÿå‘½å‘¨æœŸä¸­çš„ä½œç”¨

```rs
struct Book<'a> {
    title: &'a str,
    author: &'a str,
}

impl<'a> Book<'a> {
    // å½“æ–¹æ³•æœ‰ &self å‚æ•°æ—¶ï¼Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ self ç›¸åŒ
    fn get_title(&self) -> &str {
        self.title
    }

    // å¤šä¸ªå‚æ•°æ—¶ï¼Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ self ç›¸åŒ
    fn get_info(&self, prefix: &str) -> &str {
        self.title // è¿”å› self.titleï¼Œç”Ÿå‘½å‘¨æœŸä¸ self ç›¸åŒ
    }

    // å¯å˜å€Ÿç”¨æ–¹æ³•
    fn update_title(&mut self, new_title: &'a str) {
        self.title = new_title;
    }
}

fn main() {
    let title = String::from("Rust Programming");
    let author = String::from("Ferris");

    let mut book = Book {
        title: &title,
        author: &author,
    };

    // è°ƒç”¨æ–¹æ³•
    println!("ä¹¦åï¼š{}", book.get_title());
    println!("ä¿¡æ¯ï¼š{}", book.get_info("ä¹¦åï¼š"));

    let new_title = "Advanced Rust";
    book.update_title(&new_title);
    println!("æ›´æ–°åçš„ä¹¦åï¼š{}", book.get_title());
}
```

#### self å‚æ•°ä¸æ™®é€šå‡½æ•°çš„åŒºåˆ«

```rs
struct Counter {
    count: u32,
}

impl Counter {
    // æ–¹æ³•ï¼šä½¿ç”¨ &self å‚æ•°
    fn increment(&mut self) {
        self.count += 1;
    }

    fn get_count(&self) -> u32 {
        self.count
    }
}

// æ™®é€šå‡½æ•°ï¼šéœ€è¦æ˜¾å¼ä¼ é€’å®ä¾‹
fn increment_counter(counter: &mut Counter) {
    counter.count += 1;
}

fn get_counter_count(counter: &Counter) -> u32 {
    counter.count
}

fn main() {
    let mut counter = Counter { count: 0 };

    // ä½¿ç”¨æ–¹æ³•ï¼ˆæ›´ç®€æ´ï¼‰
    counter.increment();
    println!("è®¡æ•°ï¼š{}", counter.get_count());

    // ä½¿ç”¨æ™®é€šå‡½æ•°ï¼ˆéœ€è¦æ˜¾å¼ä¼ é€’å®ä¾‹ï¼‰
    increment_counter(&mut counter);
    println!("è®¡æ•°ï¼š{}", get_counter_count(&counter));
}
```

#### self å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸè§„åˆ™

```rs
struct Data<'a> {
    content: &'a str,
}

impl<'a> Data<'a> {
    // è§„åˆ™ï¼šå½“æ–¹æ³•æœ‰ &self å‚æ•°æ—¶ï¼Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ self ç›¸åŒ
    fn get_content(&self) -> &str {
        self.content // è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ self ç›¸åŒ
    }

    // å¤šä¸ªå‚æ•°æ—¶ï¼Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸä¸ self ç›¸åŒ
    fn combine_with(&self, other: &str) -> &str {
        self.content // å³ä½¿æœ‰å…¶ä»–å‚æ•°ï¼Œè¿”å›å€¼ä»ä¸ self ç›¸åŒ
    }

    // å¯å˜å€Ÿç”¨æ–¹æ³•
    fn update_content(&mut self, new_content: &'a str) {
        self.content = new_content;
    }
}
```

#### self å‚æ•°åœ¨ä¸åŒç±»å‹ä¸­çš„ä½¿ç”¨

```rs
// 1. ç»“æ„ä½“æ–¹æ³•
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // ä½¿ç”¨ &self çš„æ–¹æ³•
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // ä½¿ç”¨ &mut self çš„æ–¹æ³•
    fn resize(&mut self, width: u32, height: u32) {
        self.width = width;
        self.height = height;
    }

    // ä½¿ç”¨ self çš„æ–¹æ³•ï¼ˆæ¶ˆè€—å®ä¾‹ï¼‰
    fn into_square(self) -> Rectangle {
        let size = self.width.max(self.height);
        Rectangle { width: size, height: size }
    }
}

// 2. æšä¸¾æ–¹æ³•
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        match self {
            Message::Quit => println!("é€€å‡º"),
            Message::Move { x, y } => println!("ç§»åŠ¨åˆ° ({}, {})", x, y),
            Message::Write(text) => println!("å†™å…¥ï¼š{}", text),
            Message::ChangeColor(r, g, b) => println!("æ”¹å˜é¢œè‰²ï¼šRGB({}, {}, {})", r, g, b),
        }
    }
}

// 3. ç‰¹å¾æ–¹æ³•
trait Drawable {
    fn draw(&self);
    fn get_position(&self) -> (i32, i32);
}

struct Circle {
    x: i32,
    y: i32,
    radius: u32,
}

impl Drawable for Circle {
    fn draw(&self) {
        println!("ç»˜åˆ¶åœ†å½¢ï¼šä½ç½® ({}, {}), åŠå¾„{}", self.x, self.y, self.radius);
    }

    fn get_position(&self) -> (i32, i32) {
        (self.x, self.y)
    }
}

// 4. æ‰©å±•æ–¹æ³•ï¼ˆä¸ºç°æœ‰ç±»å‹æ·»åŠ æ–¹æ³•ï¼‰
trait StringExt {
    fn count_words(&self) -> usize;
    fn reverse(&self) -> String;
}

impl StringExt for String {
    fn count_words(&self) -> usize {
        self.split_whitespace().count()
    }

    fn reverse(&self) -> String {
        self.chars().rev().collect()
    }
}

fn main() {
    // ä½¿ç”¨ç»“æ„ä½“æ–¹æ³•
    let mut rect = Rectangle { width: 10, height: 20 };
    println!("é¢ç§¯ï¼š{}", rect.area());
    rect.resize(15, 25);
    println!("è°ƒæ•´åé¢ç§¯ï¼š{}", rect.area());

    // ä½¿ç”¨æšä¸¾æ–¹æ³•
    let msg = Message::Write(String::from("Hello"));
    msg.call();

    // ä½¿ç”¨ç‰¹å¾æ–¹æ³•
    let circle = Circle { x: 100, y: 200, radius: 50 };
    circle.draw();
    let pos = circle.get_position();
    println!("ä½ç½®ï¼š{:?}", pos);

    // ä½¿ç”¨æ‰©å±•æ–¹æ³•
    let text = String::from("Hello World");
    println!("å•è¯æ•°ï¼š{}", text.count_words());
    println!("åè½¬ï¼š{}", text.reverse());
}
```

#### self å‚æ•°çš„é‡è¦æ€§

1. **é¢å‘å¯¹è±¡ç¼–ç¨‹**ï¼š`self` å‚æ•°è®© Rust æ”¯æŒé¢å‘å¯¹è±¡ç¼–ç¨‹é£æ ¼
2. **æ–¹æ³•è°ƒç”¨è¯­æ³•**ï¼š`instance.method()` æ¯” `function(instance)` æ›´è‡ªç„¶
3. **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼š`self` å‚æ•°å¸®åŠ©ç¼–è¯‘å™¨æ¨æ–­è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ
4. **æ‰€æœ‰æƒè¯­ä¹‰**ï¼šä¸åŒçš„ `self` å½¢å¼è¡¨è¾¾ä¸åŒçš„æ‰€æœ‰æƒæ„å›¾
   - `&self`ï¼šåªè¯»è®¿é—®
   - `&mut self`ï¼šå¯ä¿®æ”¹è®¿é—®
   - `self`ï¼šè·å–æ‰€æœ‰æƒ
5. **ä»£ç ç»„ç»‡**ï¼šå°†ç›¸å…³çš„åŠŸèƒ½ç»„ç»‡åœ¨ç±»å‹çš„æ–¹æ³•ä¸­
6. **ç±»å‹å®‰å…¨**ï¼šç¡®ä¿æ–¹æ³•åªèƒ½è¢«æ­£ç¡®çš„ç±»å‹è°ƒç”¨

#### self å‚æ•° vs æ™®é€šå‡½æ•°å‚æ•°

```rs
struct Person {
    name: String,
    age: u32,
}

// æ–¹æ³•ï¼šä½¿ç”¨ self å‚æ•°
impl Person {
    fn introduce(&self) {
        println!("æˆ‘å« {}, ä»Šå¹´ {} å²", self.name, self.age);
    }

    fn have_birthday(&mut self) {
        self.age += 1;
        println!("{} è¿‡ç”Ÿæ—¥äº†ï¼Œç°åœ¨ {} å²", self.name, self.age);
    }
}

// æ™®é€šå‡½æ•°ï¼šä½¿ç”¨æ™®é€šå‚æ•°
fn introduce_person(person: &Person) {
    println!("æˆ‘å« {}, ä»Šå¹´ {} å²", person.name, person.age);
}

fn have_birthday_person(person: &mut Person) {
    person.age += 1;
    println!("{} è¿‡ç”Ÿæ—¥äº†ï¼Œç°åœ¨ {} å²", person.name, person.age);
}

fn main() {
    let mut person = Person {
        name: String::from("Ferris"),
        age: 25,
    };

    // ä½¿ç”¨æ–¹æ³•ï¼ˆself å‚æ•°ï¼‰
    person.introduce();
    person.have_birthday();

    // ä½¿ç”¨æ™®é€šå‡½æ•°ï¼ˆæ™®é€šå‚æ•°ï¼‰
    introduce_person(&person);
    have_birthday_person(&mut person);
}
```

#### ä¸ºä»€ä¹ˆ self å‚æ•°åªèƒ½åœ¨æ–¹æ³•ä¸­ä½¿ç”¨

```rs
// é”™è¯¯ï¼šä¸èƒ½åœ¨æ™®é€šå‡½æ•°ä¸­ä½¿ç”¨ self å‚æ•°
// fn wrong_function(self) {  // ç¼–è¯‘é”™è¯¯ï¼šself å‚æ•°åªèƒ½åœ¨æ–¹æ³•ä¸­ä½¿ç”¨
//     println!("è¿™æ˜¯é”™è¯¯çš„ç”¨æ³•");
// }

// æ­£ç¡®ï¼šæ™®é€šå‡½æ•°ä½¿ç”¨æ™®é€šå‚æ•°
fn correct_function(data: String) {
    println!("è¿™æ˜¯æ­£ç¡®çš„ç”¨æ³•ï¼š{}", data);
}

// æ­£ç¡®ï¼šæ–¹æ³•ä¸­ä½¿ç”¨ self å‚æ•°
struct Example;

impl Example {
    fn method_with_self(&self) {
        println!("è¿™æ˜¯æ­£ç¡®çš„æ–¹æ³•");
    }
}
```

#### self å‚æ•°çš„é™åˆ¶

1. **åªèƒ½åœ¨ impl å—ä¸­ä½¿ç”¨**ï¼š`self` å‚æ•°åªèƒ½åœ¨ç»“æ„ä½“ã€æšä¸¾æˆ–ç‰¹å¾çš„ `impl` å—ä¸­å®šä¹‰
2. **ä¸èƒ½åœ¨æ™®é€šå‡½æ•°ä¸­ä½¿ç”¨**ï¼šæ™®é€šå‡½æ•°ä¸èƒ½ä½¿ç”¨ `self` å‚æ•°
3. **ä¸èƒ½åœ¨ trait å®šä¹‰å¤–ä½¿ç”¨**ï¼š`self` å‚æ•°åªèƒ½åœ¨ trait å®šä¹‰æˆ– impl å—ä¸­ä½¿ç”¨
4. **å¿…é¡»æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°**ï¼š`self` å‚æ•°å¿…é¡»æ˜¯æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°

#### å®é™…åº”ç”¨ä¸­çš„é€‰æ‹©

```rs
// åœºæ™¯ 1ï¼šå½“åŠŸèƒ½ä¸ç‰¹å®šç±»å‹ç´§å¯†ç›¸å…³æ—¶ï¼Œä½¿ç”¨æ–¹æ³•ï¼ˆself å‚æ•°ï¼‰
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

// åœºæ™¯ 2ï¼šå½“åŠŸèƒ½æ˜¯é€šç”¨çš„å·¥å…·å‡½æ•°æ—¶ï¼Œä½¿ç”¨æ™®é€šå‡½æ•°
fn calculate_distance(p1: (f64, f64), p2: (f64, f64)) -> f64 {
    let dx = p2.0 - p1.0;
    let dy = p2.1 - p1.1;
    (dx * dx + dy * dy).sqrt()
}

fn main() {
    let rect = Rectangle { width: 10, height: 20 };
    println!("é¢ç§¯ï¼š{}", rect.area()); // ä½¿ç”¨æ–¹æ³•

    let distance = calculate_distance((0.0, 0.0), (3.0, 4.0)); // ä½¿ç”¨æ™®é€šå‡½æ•°
    println!("è·ç¦»ï¼š{}", distance);
}
```

#### ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„é‡è¦æ€§

ç”Ÿå‘½å‘¨æœŸæ³¨è§£å¸®åŠ© Rust ç¼–è¯‘å™¨ï¼š

1. **é˜²æ­¢æ‚¬å‚å¼•ç”¨**ï¼šç¡®ä¿å¼•ç”¨ä¸ä¼šæŒ‡å‘å·²é‡Šæ”¾çš„å†…å­˜
2. **ä¿è¯å†…å­˜å®‰å…¨**ï¼šåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å¼•ç”¨çš„æœ‰æ•ˆæ€§
3. **ä¼˜åŒ–æ€§èƒ½**ï¼šä¸éœ€è¦è¿è¡Œæ—¶æ£€æŸ¥
4. **æä¾›æ¸…æ™°çš„ API**ï¼šæ˜ç¡®å‡½æ•°çš„å¼•ç”¨è¦æ±‚

# æ‚¬å‚å¼•ç”¨ï¼ˆDangling Referencesï¼‰

æ‚¬å‚å¼•ç”¨æ˜¯æŒ‡å¼•ç”¨æŒ‡å‘çš„å†…å­˜å·²ç»è¢«é‡Šæ”¾ï¼Œä½†å¼•ç”¨ä»ç„¶å­˜åœ¨çš„æƒ…å†µã€‚æ¯”å¦‚å°è¯•ä½¿ç”¨ç¦»å¼€ä½œç”¨åŸŸçš„å€¼çš„å¼•ç”¨ã€‚è¿™ä¼šå¯¼è‡´ç¨‹åºè®¿é—®æ— æ•ˆå†…å­˜ï¼Œæ˜¯å†…å­˜å®‰å…¨çš„é‡è¦é—®é¢˜ã€‚

### ä»€ä¹ˆæ˜¯æ‚¬å‚å¼•ç”¨

æ‚¬å‚å¼•ç”¨å°±åƒæŒ‡å‘ä¸€ä¸ªå·²ç»è¢«æ‹†é™¤çš„æˆ¿å­ï¼Œä½ æ‹¿ç€åœ°å€ï¼Œä½†æˆ¿å­å·²ç»ä¸å­˜åœ¨äº†ã€‚åœ¨ç¼–ç¨‹ä¸­ï¼Œè¿™é€šå¸¸å‘ç”Ÿåœ¨ï¼š

1. **å˜é‡ç¦»å¼€ä½œç”¨åŸŸ**ï¼šå±€éƒ¨å˜é‡è¢«é‡Šæ”¾ï¼Œä½†å¼•ç”¨ä»ç„¶å­˜åœ¨
2. **å†…å­˜è¢«é‡Šæ”¾**ï¼šåŠ¨æ€åˆ†é…çš„å†…å­˜è¢«é‡Šæ”¾ï¼Œä½†æŒ‡é’ˆä»ç„¶æŒ‡å‘è¯¥åœ°å€
3. **æ•°æ®è¢«ç§»åŠ¨**ï¼šæ•°æ®çš„æ‰€æœ‰æƒè¢«è½¬ç§»ï¼Œä½†å¼•ç”¨ä»ç„¶æŒ‡å‘åŸä½ç½®

### æ‚¬å‚å¼•ç”¨çš„ä¾‹å­

```rs
// è¿™é‡Œæˆ‘ä»¬çœ‹ä¸‹æ‚¬å‚å¼•ç”¨çš„ä¾‹å­ã€‚
{
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}
```

å˜é‡ x çš„ä½œç”¨åŸŸåœ¨å†…éƒ¨çš„{}ä¸­ï¼Œæ­¤æ—¶å˜é‡ r è·å–åˆ°äº† x çš„å¼•ç”¨ï¼Œä½†åœ¨å†…éƒ¨{}ä¹‹åï¼Œå˜é‡ x è¢« Rust é‡Šæ”¾ï¼Œç”±äºå˜é‡ r çš„ä½œç”¨åŸŸä¸€ç›´åˆ°å¤–éƒ¨çš„{}ï¼Œä¹Ÿå°±æ˜¯æ­¤æ—¶ r ä¾ç„¶æœ‰æ•ˆï¼Œä½†æ˜¯å®ƒçš„å€¼ä¸å­˜åœ¨äº†ï¼Œå› æ­¤å˜é‡ r æˆäº†æ‚¬å‚å¼•ç”¨ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆç¼–è¯‘å™¨ä¼šæç¤º x does not live long enough, borrowed value does not live long enoughã€‚

å€Ÿç”¨æ£€æŸ¥å™¨ï¼ˆborrow checkerï¼‰æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ

Rust ç¼–è¯‘å™¨æœ‰ä¸€ä¸ªå€Ÿç”¨æ£€æŸ¥å™¨ï¼Œå®ƒæ¯”è¾ƒä½œç”¨åŸŸæ¥ç¡®ä¿æ‰€æœ‰çš„å€Ÿç”¨éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚å¯¹äºä¸Šé¢çš„ä¾‹å­ï¼Œå€Ÿç”¨æ£€æŸ¥å™¨ä¼šå¯¹å˜é‡çš„ä½œç”¨åŸŸèŒƒå›´è¿›è¡Œæ ‡æ³¨ï¼Œå¦‚ä¸‹ï¼š

```rs
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}
```

æˆ‘ä»¬ä¼šå‘ç°å˜é‡ r çš„ä½œç”¨åŸŸæ˜¯ 'a æ‰€æ ‡è¯†çš„èŒƒå›´ï¼Œè€Œå˜é‡ x çš„ä½œç”¨åŸŸæ˜¯ 'b æ‰€æ ‡è¯†çš„èŒƒå›´ï¼Œæ­¤æ—¶ 'b çš„èŒƒå›´å°äº 'aï¼Œå³å˜é‡ r å¼•ç”¨çš„ä½œç”¨åŸŸå¤§äºå€¼çš„ä½œç”¨åŸŸï¼Œå€Ÿç”¨æ£€æŸ¥å™¨å°±ä¼šå‘ç°è¿™ä¸ªå¼•ç”¨å¯èƒ½æ˜¯æ— æ•ˆçš„ã€‚

å¯¹äºä¸Šé¢çš„ä¾‹å­ï¼Œå¦‚ä½•æ‰èƒ½é€šè¿‡å€Ÿç”¨æ£€æŸ¥å™¨çš„æ£€æŸ¥ï¼Ÿ

åªéœ€è¦ä¿è¯å€¼çš„ä½œç”¨åŸŸ 'b å¤§äº å¼•ç”¨çš„ä½œç”¨åŸŸ 'a å³å¯ã€‚æ¢å¥è¯è¯´ï¼Œåªè¦å€ºä¸»ä¸€ç›´æ´»ç€ï¼ŒRust çš„ä¸–ç•Œé‡Œå°±è®¤ä¸ºè¿™ä¸ªå€Ÿè´·æ˜¯å…è®¸çš„ã€‚

```rs
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

```rs
// ä¾‹å­ 1ï¼šå‡½æ•°è¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨ï¼ˆç¼–è¯‘é”™è¯¯ï¼‰
fn create_dangling_reference() -> &String {
    let s = String::from("hello");
    &s // é”™è¯¯ï¼šè¿”å›å¯¹å±€éƒ¨å˜é‡çš„å¼•ç”¨
} // s åœ¨è¿™é‡Œç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

// ä¾‹å­ 2ï¼šå¼•ç”¨æŒ‡å‘è¢«é‡Šæ”¾çš„æ•°æ®
fn demonstrate_dangling() {
    let r; // å£°æ˜ä¸€ä¸ªå¼•ç”¨å˜é‡

    {
        let x = 5;
        r = &x; // r å¼•ç”¨ x
    } // x åœ¨è¿™é‡Œç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

    // println!("r = {}", r); // é”™è¯¯ï¼šr ç°åœ¨æ˜¯æ‚¬å‚å¼•ç”¨
}

// ä¾‹å­ 3ï¼šåœ¨ç»“æ„ä½“ä¸­å­˜å‚¨æ‚¬å‚å¼•ç”¨
struct DanglingStruct {
    text: &String, // è¿™ä¸ªå¼•ç”¨å¯èƒ½å˜æˆæ‚¬å‚çš„
}

fn create_dangling_struct() {
    let s = String::from("hello");
    let ds = DanglingStruct { text: &s };
    // s åœ¨è¿™é‡Œç¦»å¼€ä½œç”¨åŸŸï¼Œds.text å˜æˆæ‚¬å‚å¼•ç”¨
}
```

### Rust å¦‚ä½•é˜²æ­¢æ‚¬å‚å¼•ç”¨

Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨åœ¨ç¼–è¯‘æ—¶æ£€æµ‹æ‚¬å‚å¼•ç”¨ï¼š

```rs
fn main() {
    // æ­£ç¡®çš„åšæ³•ï¼šè¿”å›æ‰€æœ‰æƒè€Œä¸æ˜¯å¼•ç”¨
    let s1 = no_dangle();
    println!("s1 = {}", s1);

    // æ­£ç¡®çš„åšæ³•ï¼šç¡®ä¿å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
    let s2 = String::from("hello");
    let len = calculate_length(&s2);
    println!("'{}' çš„é•¿åº¦æ˜¯ {}", s2, len);
}

// æ­£ç¡®çš„å‡½æ•°ï¼šè¿”å›æ‰€æœ‰æƒ
fn no_dangle() -> String {
    let s = String::from("hello");
    s // è¿”å›æ‰€æœ‰æƒï¼Œè€Œä¸æ˜¯å¼•ç”¨
}

// æ­£ç¡®çš„å‡½æ•°ï¼šæ¥å—å¼•ç”¨ä½œä¸ºå‚æ•°
fn calculate_length(s: &String) -> usize {
    s.len()
}
```

### æ‚¬å‚å¼•ç”¨çš„å±å®³

1. **ç¨‹åºå´©æºƒ**ï¼šè®¿é—®æ— æ•ˆå†…å­˜å¯èƒ½å¯¼è‡´ç¨‹åºå´©æºƒ
2. **æ•°æ®æŸå**ï¼šå¯èƒ½è¯»å–åˆ°åƒåœ¾æ•°æ®
3. **å®‰å…¨æ¼æ´**ï¼šå¯èƒ½è¢«æ¶æ„åˆ©ç”¨
4. **ä¸å¯é¢„æµ‹çš„è¡Œä¸º**ï¼šç¨‹åºè¡Œä¸ºå˜å¾—ä¸ç¡®å®š

### ä¸ºä»€ä¹ˆ Rust èƒ½é˜²æ­¢æ‚¬å‚å¼•ç”¨

1. **ç¼–è¯‘æ—¶æ£€æŸ¥**ï¼šå€Ÿç”¨æ£€æŸ¥å™¨åœ¨ç¼–è¯‘æ—¶æ£€æµ‹æ½œåœ¨é—®é¢˜
2. **æ‰€æœ‰æƒç³»ç»Ÿ**ï¼šç¡®ä¿æ•°æ®åœ¨å¼•ç”¨å­˜åœ¨æœŸé—´ä¸ä¼šè¢«é‡Šæ”¾
3. **ç”Ÿå‘½å‘¨æœŸç®¡ç†**ï¼šé€šè¿‡ç”Ÿå‘½å‘¨æœŸæ³¨è§£æ˜ç¡®å¼•ç”¨çš„æœ‰æ•ˆèŒƒå›´
4. **å†…å­˜å®‰å…¨ä¿è¯**ï¼šå¦‚æœä»£ç èƒ½ç¼–è¯‘é€šè¿‡ï¼Œå°±ä¸ä¼šæœ‰æ‚¬å‚å¼•ç”¨

Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨æ˜¯é˜²æ­¢æ‚¬å‚å¼•ç”¨çš„å¼ºå¤§å·¥å…·ï¼Œå®ƒé€šè¿‡é™æ€åˆ†æç¡®ä¿æ‰€æœ‰å¼•ç”¨éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚

# åˆ‡ç‰‡

åˆ‡ç‰‡ï¼ˆsliceï¼‰ï¼šæ˜¯ä¸€ç§å¼•ç”¨æ•°æ®ç»“æ„ï¼Œå®ƒå…è®¸ä½ å¼•ç”¨æ•°æ®çš„ä¸€éƒ¨åˆ†è€Œä¸éœ€è¦æ‹·è´æ•´ä¸ªæ•°æ®ã€‚åˆ‡ç‰‡é€šå¸¸ç”¨äºæ•°ç»„ã€å­—ç¬¦ä¸²ç­‰é›†åˆç±»å‹ã€‚

å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼ˆString sliceï¼‰ï¼šæ˜¯ä¸€ç§ç‰¹æ®Šçš„åˆ‡ç‰‡ï¼Œä¸“é—¨ç”¨äºå¤„ç†å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²åˆ‡ç‰‡çš„ç±»å‹æ˜¯ &strã€‚å®ƒå¯ä»¥é€šè¿‡ç´¢å¼•æˆ–èŒƒå›´æ¥æŒ‡å®šå­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†ã€‚å­—ç¬¦ä¸²åˆ‡ç‰‡æä¾›äº†å¯¹å­—ç¬¦ä¸²çš„å¼•ç”¨ï¼Œè€Œä¸å¼•å…¥é¢å¤–çš„å†…å­˜å¼€é”€ã€‚æœ¬èŠ‚æˆ‘ä»¬è®¨è®ºçš„æ˜¯åˆ†é…åœ¨å†…å­˜ä¸­çš„å¯åŠ¨æ€è°ƒèŠ‚å¤§å°çš„å­—ç¬¦ä¸²çš„åˆ‡ç‰‡ã€‚

æˆ‘ä»¬æ¥ä¸‹æ¥å­¦ä¹ ä¸‹åˆ‡ç‰‡çš„åŸºæœ¬è¯­æ³•ï¼Œä»¥åŠå¯¹åº”çš„å†…å­˜æ¨¡å‹ã€‚

```rs
// è¯¥å­—ç¬¦ä¸²åˆ†é…åœ¨å†…å­˜ä¸­
let s = String::from("hello world");

// hello æ²¡æœ‰å¼•ç”¨æ•´ä¸ª String å­—ç¬¦ä¸² sï¼Œè€Œæ˜¯å¼•ç”¨äº† s çš„ä¸€éƒ¨åˆ†å†…å®¹ï¼Œé€šè¿‡ [0..5] çš„æ–¹å¼æ¥æŒ‡å®šã€‚
let hello: &str = &s[0..5];
let world: &str = &s[6..11];
```

åˆ›å»ºåˆ‡ç‰‡éœ€è¦é€šè¿‡ [å¼€å§‹ç´¢å¼•..ç»ˆæ­¢ç´¢å¼•]æ¥æŒ‡å®šèŒƒå›´ï¼Œä»£è¡¨çš„æ•°æ®èŒƒå›´åŒ…å«å¼€å§‹ä½ç½®ï¼Œä½†ä¸åŒ…å«ç»“æŸä½ç½®ï¼Œå³å‰é—­åå¼€ï¼›åŒæ—¶ç´¢å¼•ä½ç½®ä» 0 å¼€å§‹ã€‚

![](./assets/rust-section.webp)

å¦‚æœå­—ç¬¦ä¸²åŒ…å«æ±‰å­—ï¼Œåœ¨è·å–å­—ç¬¦ä¸²åˆ‡ç‰‡æ—¶æœ‰ä»€ä¹ˆè¦æ³¨æ„çš„ï¼Ÿ

Aï¼šå­—ç¬¦ä¸²åˆ‡ç‰‡çš„ç´¢å¼•ä½ç½®æ˜¯æŒ‰ç…§å­—èŠ‚è€Œä¸æ˜¯å­—ç¬¦ã€‚ç”±äºæ±‰å­—ä½¿ç”¨ UTF-8 ç¼–ç ï¼Œä¸€ä¸ªæ±‰å­—ï¼ˆå­—ç¬¦ï¼‰å¯èƒ½ç”±ä¸€ä¸ªæˆ–å¤šä¸ªå­—èŠ‚ç»„æˆã€‚å› æ­¤ç´¢å¼•å¿…é¡»å¯¹åº”ä¸€ä¸ªå®Œæ•´çš„æ±‰å­—çš„è¾¹ç•Œï¼Œå¦åˆ™è·å–è¯¥æ±‰å­—ä¼šå¤±è´¥ã€‚

```rs
let chinese_string = "ä¸­å›½äºº";

// è·å–åˆ‡ç‰‡ zhong ä¼šå¤±è´¥ï¼Œå› ä¸ºä¸€ä¸ªæ±‰å­—å¯èƒ½ç”±â€œä¸€ä¸ªæˆ–å¤šä¸ªå­—èŠ‚â€ç»„æˆã€‚
// è¿™é‡Œâ€œä¸­â€å ç”¨ 3 ä¸ªå­—èŠ‚ï¼Œå› æ­¤ [0..2] å¹¶ä¸å¯¹åº”ä¸€ä¸ªå®Œæ•´çš„æ±‰å­—çš„è¾¹ç•Œ
let zhong = &chinese_string [0..2];

// æ­£ç¡®çš„å†™æ³•ï¼Œ1 ä¸ªæ±‰å­—å  3 ä¸ªå­—èŠ‚ï¼Œå³æ±‰å­—â€œä¸­â€çš„å­—èŠ‚èŒƒå›´æ˜¯ 0ã€1ã€2
let zhong = &chinese_string[0..3];
println!("{}", zhong);
```

# å­—ç¬¦ä¸²å­—é¢é‡ï¼ˆString Literalsï¼‰

å­—ç¬¦ä¸²å­—é¢é‡ï¼ˆString Literalsï¼‰ï¼šæ˜¯æŒ‡åœ¨ä»£ç ä¸­ç›´æ¥å†™æ­»çš„ã€ç”±åŒå¼•å·åŒ…å›´çš„ä¸€ç³»åˆ—å­—ç¬¦ï¼Œä¾‹å¦‚ "Hello, world!"ã€‚å®ƒç¡¬ç¼–ç åˆ°æœ€ç»ˆçš„ç¨‹åºäºŒè¿›åˆ¶ä¸­ï¼Œç±»å‹ä¸º &strï¼Œè·Ÿæˆ‘ä»¬ä¸ŠèŠ‚çš„åŠ¨æ€å­—ç¬¦ä¸²åˆ‡ç‰‡ç±»å‹ä¸€æ ·ï¼Œå› ä¸ºå®ƒä¹Ÿæ˜¯ä¸€ç§å­—ç¬¦ä¸²å¼•ç”¨ï¼Œå¯¹ç¨‹åºäºŒè¿›åˆ¶æ–‡ä»¶ä¸­é™æ€åˆ†é…çš„å­—ç¬¦ä¸²æ•°æ®çš„å¼•ç”¨ï¼Œä¹Ÿç§°ä¹‹ä¸ºé™æ€å­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚

æˆ‘ä»¬æ¥ä¸‹æ¥åˆ†åˆ«çœ‹ä¸‹å­—ç¬¦ä¸²å­—é¢é‡å’ŒåŠ¨æ€å­—ç¬¦ä¸²çš„è¯­æ³•ã€‚

```rs
// å­—ç¬¦ä¸²å­—é¢é‡ï¼Œç¼–è¯‘æ—¶å·²ç¡®å®š
let x: &str = "hello world";

// åŠ¨æ€å­—ç¬¦ä¸²
let hello: String = String::from("hello world");
// å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå¼•ç”¨æ•´ä¸ªå­—ç¬¦ä¸²
let y: &str = &hello[..];
// å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå¼•ç”¨éƒ¨åˆ†å­—ç¬¦ä¸²
let z: &str = &hello[0..3];
```

å­—ç¬¦ä¸²å­—é¢é‡ å’Œ åŠ¨æ€å­—ç¬¦ä¸²åˆ‡ç‰‡çš„å¼‚åŒç‚¹ï¼Ÿ

- ç›¸åŒç‚¹ï¼š
  - â‘ éƒ½æ˜¯éƒ½æ˜¯å¯¹å­—ç¬¦ä¸²æ•°æ®çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯å®é™…çš„å­—ç¬¦ä¸²æ•°æ®æœ¬èº«ã€‚
  - â‘¡éƒ½æ˜¯ UTF-8 ç¼–ç çš„å­—ç¬¦ä¸²ã€‚â‘¢ä¸¤è€…éƒ½å¯ä»¥ä½¿ç”¨ä¸€äº›ç›¸ä¼¼çš„å­—ç¬¦ä¸²æ“ä½œï¼Œå¦‚åˆ‡ç‰‡ã€æŸ¥æ‰¾ã€æ¯”è¾ƒç­‰ã€‚
- ä¸åŒç‚¹ï¼š
  - â‘ å­—ç¬¦ä¸²å­—é¢é‡è¢«ç¡¬ç¼–ç åˆ°ç¨‹åºäºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå› æ­¤åœ¨æ•´ä¸ªç¨‹åºè¿è¡ŒæœŸé—´æœ‰æ•ˆã€‚è€Œå­—ç¬¦ä¸²åˆ‡ç‰‡å–å†³äºå¼•ç”¨å®ƒçš„å˜é‡æˆ–æ•°æ®ç»“æ„çš„ç”Ÿå‘½å‘¨æœŸã€‚
  - â‘¡å­—ç¬¦ä¸²å­—é¢é‡åœ¨ç¼–è¯‘æ—¶å·²çŸ¥å¤§å°ï¼Œæ˜¯å›ºå®šå¤§å°çš„ï¼›å­—ç¬¦ä¸²åˆ‡ç‰‡åœ¨è¿è¡Œæ—¶ç¡®å®šå¤§å°ï¼Œæ˜¯åŠ¨æ€å¤§å°çš„ã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬ç»§ç»­å­—ç¬¦ä¸²ç›¸å…³çš„æ“ä½œï¼šè¿½åŠ ã€æ’å…¥ã€æ›¿æ¢ã€åˆ é™¤ï¼š

## å­—ç¬¦ä¸²æ“ä½œ

### 1. è¿½åŠ æ“ä½œ

```rs
fn main() {
    let mut s = String::from("Hello");

    // è¿½åŠ å­—ç¬¦
    s.push('!');
    println!("è¿½åŠ å­—ç¬¦åï¼š{}", s); // è¾“å‡ºï¼šHello!

    // è¿½åŠ å­—ç¬¦ä¸²
    s.push_str(" World");
    println!("è¿½åŠ å­—ç¬¦ä¸²åï¼š{}", s); // è¾“å‡ºï¼šHello! World

    // ä½¿ç”¨ + è¿ç®—ç¬¦è¿æ¥å­—ç¬¦ä¸²
    let s1 = String::from("Hello");
    let s2 = String::from(" World");
    let s3 = s1 + &s2; // æ³¨æ„ï¼šs1 çš„æ‰€æœ‰æƒè¢«è½¬ç§»
    println!("ä½¿ç”¨ + è¿æ¥ï¼š{}", s3);

    // ä½¿ç”¨ format! å®è¿æ¥å¤šä¸ªå­—ç¬¦ä¸²
    let s4 = String::from("Hello");
    let s5 = String::from("World");
    let s6 = format!("{} {}!", s4, s5); // s4 å’Œ s5 çš„æ‰€æœ‰æƒä¿æŒä¸å˜
    println!("ä½¿ç”¨ format! è¿æ¥ï¼š{}", s6);
}
```

### 2. æ’å…¥æ“ä½œ

```rs
fn main() {
    let mut s = String::from("Hello World");

    // åœ¨æŒ‡å®šä½ç½®æ’å…¥å­—ç¬¦
    s.insert(5, '!');
    println!("æ’å…¥å­—ç¬¦åï¼š{}", s); // è¾“å‡ºï¼šHello! World

    // åœ¨æŒ‡å®šä½ç½®æ’å…¥å­—ç¬¦ä¸²
    s.insert_str(6, "Beautiful ");
    println!("æ’å…¥å­—ç¬¦ä¸²åï¼š{}", s); // è¾“å‡ºï¼šHello! Beautiful World

    // æ³¨æ„ï¼šæ’å…¥æ“ä½œéœ€è¦ç¡®ä¿ç´¢å¼•åœ¨æœ‰æ•ˆèŒƒå›´å†…
    // s.insert(100, 'x'); // è¿™ä¼šå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
}
```

### 3. æ›¿æ¢æ“ä½œ

```rs
fn main() {
    let mut s = String::from("Hello World");

    // æ›¿æ¢æŒ‡å®šèŒƒå›´çš„å­—ç¬¦ä¸²
    s.replace_range(0..5, "Hi");
    println!("æ›¿æ¢åï¼š{}", s); // è¾“å‡ºï¼šHi World

    // æ›¿æ¢æ‰€æœ‰åŒ¹é…çš„å­å­—ç¬¦ä¸²
    let s2 = String::from("Hello Hello Hello");
    let replaced = s2.replace("Hello", "Hi");
    println!("æ›¿æ¢æ‰€æœ‰åŒ¹é…ï¼š{}", replaced); // è¾“å‡ºï¼šHi Hi Hi

    // æ›¿æ¢ç¬¬ä¸€ä¸ªåŒ¹é…çš„å­å­—ç¬¦ä¸²
    let replaced_first = s2.replacen("Hello", "Hi", 1);
    println!("æ›¿æ¢ç¬¬ä¸€ä¸ªåŒ¹é…ï¼š{}", replaced_first); // è¾“å‡ºï¼šHi Hello Hello

    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢ï¼ˆéœ€è¦ regex crateï¼‰
    // let re = Regex::new(r"Hello").unwrap();
    // let replaced_regex = re.replace_all(&s2, "Hi");
}
```

### 4. åˆ é™¤æ“ä½œ

```rs
fn main() {
    let mut s = String::from("Hello World");

    // åˆ é™¤æŒ‡å®šä½ç½®çš„å­—ç¬¦
    s.remove(5); // åˆ é™¤ç©ºæ ¼
    println!("åˆ é™¤å­—ç¬¦åï¼š{}", s); // è¾“å‡ºï¼šHelloWorld

    // åˆ é™¤æŒ‡å®šèŒƒå›´çš„å­—ç¬¦ä¸²
    s.drain(0..5); // åˆ é™¤å‰ 5 ä¸ªå­—ç¬¦
    println!("åˆ é™¤èŒƒå›´åï¼š{}", s); // è¾“å‡ºï¼šWorld

    // æ¸…ç©ºæ•´ä¸ªå­—ç¬¦ä¸²
    s.clear();
    println!("æ¸…ç©ºåé•¿åº¦ï¼š{}", s.len()); // è¾“å‡ºï¼š0

    // å¼¹å‡ºæœ€åä¸€ä¸ªå­—ç¬¦
    let mut s2 = String::from("Hello");
    let last_char = s2.pop();
    println!("å¼¹å‡ºçš„å­—ç¬¦ï¼š{:?}", last_char); // è¾“å‡ºï¼šSome('o')
    println!("å‰©ä½™å­—ç¬¦ä¸²ï¼š{}", s2); // è¾“å‡ºï¼šHell

    // æˆªæ–­å­—ç¬¦ä¸²åˆ°æŒ‡å®šé•¿åº¦
    let mut s3 = String::from("Hello World");
    s3.truncate(5);
    println!("æˆªæ–­åï¼š{}", s3); // è¾“å‡ºï¼šHello
}
```

### 5. æŸ¥æ‰¾å’Œæœç´¢

```rs
fn main() {
    let s = String::from("Hello World");

    // æŸ¥æ‰¾å­å­—ç¬¦ä¸²çš„ä½ç½®
    if let Some(pos) = s.find("World") {
        println!("'World' åœ¨ä½ç½®ï¼š{}", pos); // è¾“å‡ºï¼š6
    }

    // æŸ¥æ‰¾å­—ç¬¦çš„ä½ç½®
    if let Some(pos) = s.find('o') {
        println!("'o' åœ¨ä½ç½®ï¼š{}", pos); // è¾“å‡ºï¼š4
    }

    // ä»åå¾€å‰æŸ¥æ‰¾
    if let Some(pos) = s.rfind('o') {
        println!("æœ€åä¸€ä¸ª 'o' åœ¨ä½ç½®ï¼š{}", pos); // è¾“å‡ºï¼š7
    }

    // æ£€æŸ¥æ˜¯å¦åŒ…å«å­å­—ç¬¦ä¸²
    println!("åŒ…å« 'Hello': {}", s.contains("Hello")); // è¾“å‡ºï¼štrue
    println!("åŒ…å« 'Python': {}", s.contains("Python")); // è¾“å‡ºï¼šfalse

    // æ£€æŸ¥æ˜¯å¦ä»¥æŒ‡å®šå­—ç¬¦ä¸²å¼€å¤´
    println!("ä»¥ 'Hello' å¼€å¤´ï¼š{}", s.starts_with("Hello")); // è¾“å‡ºï¼štrue

    // æ£€æŸ¥æ˜¯å¦ä»¥æŒ‡å®šå­—ç¬¦ä¸²ç»“å°¾
    println!("ä»¥ 'World' ç»“å°¾ï¼š{}", s.ends_with("World")); // è¾“å‡ºï¼štrue
}
```

### 6. å­—ç¬¦ä¸²åˆ†å‰²å’Œè¿­ä»£

```rs
fn main() {
    let s = String::from("Hello,World,Rust");

    // æŒ‰åˆ†éš”ç¬¦åˆ†å‰²å­—ç¬¦ä¸²
    let parts: Vec<&str> = s.split(',').collect();
    println!("åˆ†å‰²ç»“æœï¼š{:?}", parts); // è¾“å‡ºï¼š["Hello", "World", "Rust"]

    // æŒ‰ç©ºç™½å­—ç¬¦åˆ†å‰²
    let s2 = String::from("Hello World Rust");
    let words: Vec<&str> = s2.split_whitespace().collect();
    println!("æŒ‰ç©ºç™½åˆ†å‰²ï¼š{:?}", words); // è¾“å‡ºï¼š["Hello", "World", "Rust"]

    // æŒ‰è¡Œåˆ†å‰²
    let s3 = String::from("Line 1\nLine 2\nLine 3");
    let lines: Vec<&str> = s3.lines().collect();
    println!("æŒ‰è¡Œåˆ†å‰²ï¼š{:?}", lines); // è¾“å‡ºï¼š["Line 1", "Line 2", "Line 3"]

    // è¿­ä»£å­—ç¬¦ä¸²çš„å­—ç¬¦
    for c in s.chars() {
        print!("{} ", c);
    }
    println!(); // è¾“å‡ºï¼šH e l l o , W o r l d , R u s t

    // è¿­ä»£å­—ç¬¦ä¸²çš„å­—èŠ‚
    for b in s.bytes() {
        print!("{} ", b);
    }
    println!(); // è¾“å‡ºï¼š72 101 108 108 111 44 87 111 114 108 100 44 82 117 115 116
}
```

### 7. å­—ç¬¦ä¸²è½¬æ¢

```rs
fn main() {
    let s = String::from("Hello World");

    // è½¬æ¢ä¸ºå¤§å†™
    let upper = s.to_uppercase();
    println!("å¤§å†™ï¼š{}", upper); // è¾“å‡ºï¼šHELLO WORLD

    // è½¬æ¢ä¸ºå°å†™
    let lower = s.to_lowercase();
    println!("å°å†™ï¼š{}", lower); // è¾“å‡ºï¼šhello world

    // è½¬æ¢ä¸ºå­—ç¬¦ä¸²åˆ‡ç‰‡
    let slice: &str = &s;
    println!("å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼š{}", slice);

    // ä»å­—ç¬¦ä¸²åˆ‡ç‰‡åˆ›å»º String
    let str_slice = "Hello";
    let string_from_slice = str_slice.to_string();
    println!("ä»åˆ‡ç‰‡åˆ›å»ºï¼š{}", string_from_slice);

    // ä½¿ç”¨ String::from åˆ›å»º
    let string_from = String::from("Hello");
    println!("ä½¿ç”¨ from åˆ›å»ºï¼š{}", string_from);
}
```

### 8. å­—ç¬¦ä¸²æ ¼å¼åŒ–

```rs
fn main() {
    let name = "Ferris";
    let age = 25;

    // åŸºæœ¬æ ¼å¼åŒ–
    let formatted = format!("æˆ‘å« {}, ä»Šå¹´ {} å²", name, age);
    println!("{}", formatted);

    // ä½¿ç”¨ä½ç½®å‚æ•°
    let formatted2 = format!("{1} ä»Šå¹´ {0} å²", age, name);
    println!("{}", formatted2);

    // ä½¿ç”¨å‘½åå‚æ•°
    let formatted3 = format!("æˆ‘å« {name}, ä»Šå¹´ {age} å²");
    println!("{}", formatted3);

    // æ•°å­—æ ¼å¼åŒ–
    let pi = 3.14159;
    println!("Ï€ = {:.2}", pi); // è¾“å‡ºï¼šÏ€ = 3.14
    println!("Ï€ = {:.4}", pi); // è¾“å‡ºï¼šÏ€ = 3.1416

    // å¯¹é½å’Œå¡«å……
    let text = "Hello";
    println!("{:>10}", text); // å³å¯¹é½ï¼Œå®½åº¦ 10
    println!("{:<10}", text); // å·¦å¯¹é½ï¼Œå®½åº¦ 10
    println!("{:^10}", text); // å±…ä¸­å¯¹é½ï¼Œå®½åº¦ 10
    println!("{:0>10}", text); // å³å¯¹é½ï¼Œç”¨ 0 å¡«å……
}
```

è¿™äº›å­—ç¬¦ä¸²æ“ä½œæä¾›äº†å¼ºå¤§çš„å­—ç¬¦ä¸²å¤„ç†èƒ½åŠ›ï¼Œè®© Rust èƒ½å¤Ÿé«˜æ•ˆåœ°å¤„ç†å„ç§å­—ç¬¦ä¸²ç›¸å…³çš„ä»»åŠ¡ã€‚

# å…ƒç»„

æ˜¯ç”±å¤šç§ç±»å‹å…ƒç´ ç»„åˆåˆ°ä¸€èµ·å½¢æˆçš„é›†åˆï¼Œå› æ­¤å®ƒæ˜¯å¤åˆç±»å‹ï¼Œå¹¶ä¸”å®ƒçš„é•¿åº¦ã€é¡ºåºæ˜¯å›ºå®šçš„ã€‚å…ƒç»„é€šè¿‡ä½¿ç”¨åœ†æ‹¬å· ( ) æ¥å®šä¹‰ï¼Œå…¶ä¸­åŒ…å«äº†å¤šä¸ªå€¼ï¼Œå„ä¸ªå€¼ä¹‹é—´ç”¨é€—å· , åˆ†éš”ã€‚

å…ƒç»„çš„åˆ›å»º

```rs
// åˆ›å»º 1 ä¸ªé•¿åº¦ä¸º 4ï¼Œå¤šç§ä¸åŒå…ƒç´ ç±»å‹çš„å…ƒç»„
let tup: (i32, f64, u8, &str) = (100, 1.1, 1, "è¿™æ˜¯ä¸€ä¸ªå…ƒç»„");

// å…ƒç»„çš„æˆå‘˜è¿˜å¯ä»¥æ˜¯ä¸€ä¸ªå…ƒç»„
let tup2: (u8, (i16, u32)) = (0, (-1, 1));
```

# ç»“æ„ä½“

æ˜¯ä¸€ç§è‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œç”¨äºç»„ç»‡å’Œå­˜å‚¨ä¸åŒç±»å‹çš„æ•°æ®æˆå‘˜ã€‚å®ƒå…è®¸ä½ åˆ›å»ºä¸€ä¸ªåŒ…å«å¤šä¸ªå­—æ®µçš„æ•°æ®ç»“æ„ï¼Œæ¯ä¸ªå­—æ®µéƒ½æœ‰è‡ªå·±çš„ç±»å‹å’Œåç§°ï¼Œä½¿å¾—ä»£ç æ›´å…·å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚é€šè¿‡ struct å…³é”®å­—å®šä¹‰ã€‚

ä»¥æ±½è½¦ä¸ºä¾‹ï¼Œæˆ‘ä»¬å­¦ä¹ ä¸‹å¦‚ä½•å®šä¹‰ç»“æ„ä½“ï¼šstruct å…³é”®å­— + Car ç»“æ„ä½“åç§° + æ¸…æ™°æ˜ç¡®çš„å­—æ®µåŠç±»å‹ã€‚

```rs
struct Car {
    // å“ç‰Œ
    brand: String,
    // é¢œè‰²
    color: String,
    // ç”Ÿäº§å¹´ä»½
    year: String,
    // æ˜¯å¦æ–°èƒ½æº
    is_new_energy: bool,
    // ä»·æ ¼
    price: f64
}
```

# å…ƒç»„ç»“æ„ä½“ (Tuple Struct)

ç»“æ„ä½“å¿…é¡»è¦æœ‰åç§°ï¼Œä½†æ˜¯ç»“æ„ä½“çš„å­—æ®µå¯ä»¥æ²¡æœ‰åç§°ï¼Œè¿™ç§ç»“æ„ä½“é•¿å¾—å¾ˆåƒå…ƒç»„ï¼Œå› æ­¤è¢«ç§°ä¸ºå…ƒç»„ç»“æ„ä½“ã€‚

å¦‚æœä½ å¸Œæœ›æœ‰ä¸€ä¸ªæ•´ä½“åç§°ï¼Œä½†æ˜¯åˆä¸å…³å¿ƒé‡Œé¢å­—æ®µçš„åç§°ã€‚ä¾‹å¦‚ä¸‹é¢çš„ Point å…ƒç»„ç»“æ„ä½“ï¼Œä¼—æ‰€å‘¨çŸ¥ 3D ç‚¹æ˜¯ (x, y, z) å½¢å¼çš„åæ ‡ç‚¹ï¼Œå› æ­¤æˆ‘ä»¬æ— éœ€å†ä¸ºå†…éƒ¨çš„å­—æ®µé€ä¸€å‘½åä¸ºï¼šx, y, zã€‚

```rs
// åªæœ‰ç»“æ„ä½“åç§°ï¼šColorï¼Œæ²¡æœ‰å­—æ®µåç§°
struct Color(i32, i32, i32);
// åªæœ‰ç»“æ„ä½“åç§°ï¼šPointï¼Œæ²¡æœ‰å­—æ®µåç§°
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

# æšä¸¾ï¼ˆEnumï¼‰

æšä¸¾ï¼ˆEnumï¼‰æ˜¯ä¸€ç§ç”¨æˆ·è‡ªå®šä¹‰æ•°æ®ç±»å‹ï¼Œå®ƒå…è®¸ä½ åˆ—ä¸¾ä¸€äº›å¯èƒ½çš„å€¼ï¼Œä¹Ÿå«å˜ä½“ï¼ˆvariantsï¼‰ï¼Œæ¯ä¸ªå˜ä½“ä¹Ÿå¯ä»¥åŒ…å«ä¸åŒç±»å‹çš„æ•°æ®ã€‚æšä¸¾ä¸»è¦ç”¨äºè¡¨ç¤ºä¸åŒç§ç±»çš„é€‰é¡¹æˆ–æ“ä½œï¼Œä»¥åŠè¿›è¡Œæ¨¡å¼åŒ¹é…ç­‰åœºæ™¯ã€‚å®ƒçš„å®šä¹‰å¦‚ä¸‹ï¼š

```rs
enum æšä¸¾å {
	variants1,
	variants2,
	â€¦â€¦
}
```

æˆ‘ä»¬ä»¥äº¤é€šä¿¡å·ç¯ä¸ºä¾‹ï¼Œçœ‹çœ‹å®ƒçš„æšä¸¾æ˜¯ä»€ä¹ˆã€‚

```rs
// é€šè¿‡ enum å…³é”®å­—å®šä¹‰
enum TrafficLight {
  // è¿™é‡Œæšä¸¾å‡ºæ‰€æœ‰çš„å–å€¼
  Red,
  Yellow,
  Green,
}
```

## Option æšä¸¾

Option æšä¸¾ä¸»è¦ç”¨äºå¤„ç†å¯èƒ½å‡ºç°ç©ºå€¼çš„æƒ…å†µï¼Œä»¥é¿å…ä½¿ç”¨ç©ºæŒ‡é’ˆå¼•èµ·çš„è¿è¡Œæ—¶é”™è¯¯ã€‚å®ƒçš„å®šä¹‰å¦‚ä¸‹ï¼š

```rs
// å®ƒæœ‰ä¸¤ä¸ªæšä¸¾å€¼ï¼ŒSome(T): åŒ…å«ä¸€ä¸ªå…·ä½“çš„å€¼ Tï¼Œä»¥åŠ None: è¡¨ç¤ºæ²¡æœ‰å€¼ã€‚
enum Option<T> {
	None,
	Some(T),
}
```

ä¸‹é¢çš„ä¾‹å­ä¸­ divide å‡½æ•°çš„è¿”å›å€¼å°±æ˜¯ Option æšä¸¾ã€‚è¯·æ³¨æ„ï¼šRust çš„ æ ‡å‡†åº“ prelude ä¸­ï¼ŒOption æšä¸¾æ˜¯é»˜è®¤å¯¼å…¥çš„ï¼Œå› æ­¤åœ¨ä»£ç ä¸­ä½¿ç”¨ Option æ—¶æ— éœ€æ˜¾å¼ä½¿ç”¨ Option:: å‰ç¼€æˆ–è€…é€šè¿‡ use è¯­å¥æ˜¾å¼å¯¼å…¥ã€‚

```rs
// å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¿”å›ä¸€ä¸ª Option æšä¸¾
fn divide(x: f64, y: f64) -> Option<f64> {
    if y == 0.0 {
        None
    } else {
        Some(x / y)
    }
}

fn main() {
    // è°ƒç”¨å‡½æ•°å¹¶åŒ¹é… Option çš„å˜ä½“
    let result1 = divide(10.0, 2.0);
    match result1 {
				// è¿™é‡Œä¸éœ€è¦æ˜¾å¼ä½¿ç”¨ Option::Some(data)
        Some(_data) => println!("result1:{:?}", result1),
        None => println!("result1: None"),
    }

    // å½“åˆ†æ¯ä¸º 0ï¼Œè¿”å› None å€¼
    let result2 = divide(10.0, 0.0);
    match result2 {
        Some(_data) => println!("result2:{:?}", result2),
        None => println!("result2: None"),
    }
}
```

# æ•°ç»„

æ˜¯å°†å¤šä¸ªç›¸åŒç±»å‹çš„å…ƒç´ ä¾æ¬¡ç»„åˆåœ¨ä¸€èµ·ï¼Œå½¢æˆçš„é›†åˆã€‚åœ¨ Rust ä¸­å¸¸ç”¨çš„æ•°ç»„æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯ç›´æ¥åˆ†é…åœ¨æ ˆå†…å­˜ä¸­ï¼Œé€Ÿåº¦å¾ˆå¿«ä½†æ˜¯é•¿åº¦å›ºå®šçš„é™æ€æ•°ç»„ arrayï¼Œå¦ä¸€ç§åˆ™æ˜¯åˆ†é…åœ¨å †å†…å­˜ä¸­ï¼Œå¯åŠ¨æ€å¢é•¿ï¼Œä½†æœ‰æ€§èƒ½æŸè€—çš„åŠ¨æ€æ•°ç»„ Vectorã€‚

å…ƒç»„è·Ÿæ•°ç»„æœ€é‡è¦çš„åŒºåˆ«å°±æ˜¯å®ƒä¸åŒç±»å‹çš„å…ƒç´ é›†åˆï¼Œè€Œæ•°ç»„æ˜¯ç›¸åŒç±»å‹çš„å…ƒç´ ã€‚

## é™æ€æ•°ç»„

ä¸åŒæ–¹å¼åˆ›å»ºé™æ€æ•°ç»„çš„è¯­æ³•

```rs
// ä¸æŒ‡å®šå…ƒç´ ç±»å‹ï¼Œç”±ç¼–è¯‘å™¨æ¨æ–­
let a = [1, 2, 3, 4, 5];

// [ç±»å‹;é•¿åº¦] æ˜¾å¼æŒ‡å®šç±»å‹åŠé•¿åº¦
let b: [i32; 5] = [1, 2, 3, 4, 5];

// [åˆå§‹å€¼;é•¿åº¦] åˆå§‹åŒ–ä¸€ä¸ªæŸä¸ªå€¼é‡å¤å‡ºç° N æ¬¡çš„æ•°ç»„ï¼Œc = [3,3,3,3,3]
let c = [3; 5];
```

## åŠ¨æ€æ•°ç»„

åŠ¨æ€æ•°ç»„ Vec<T>æ˜¯ä¸€ç§çµæ´»çš„æ•°æ®ç»“æ„ï¼Œå…è®¸åœ¨è¿è¡Œæ—¶åŠ¨æ€æ”¹å˜å¤§å°ã€‚æ‰€ä»¥å®ƒçš„é•¿åº¦æ˜¯å¯å˜çš„ï¼Œå¯ä»¥æ ¹æ®éœ€è¦åŠ¨æ€å¢åŠ æˆ–å‡å°‘å…ƒç´ ã€‚è¿™ä¸ºå¤„ç†ä¸ç¡®å®šæ•°é‡çš„æ•°æ®æä¾›äº†ä¾¿åˆ©ï¼Œæ¯”å¦‚è¯»å–æœªçŸ¥æ•°é‡çš„ç”¨æˆ·è¾“å…¥æˆ–åŠ¨æ€ç”Ÿæˆæ•°æ®é›†ã€‚

ä¸ String ç±»å‹ä¸åŒï¼ŒåŠ¨æ€æ•°ç»„ Vec<T>æ˜¯é€šç”¨çš„ï¼Œå¯ä»¥å­˜å‚¨â€œä»»ä½•ç±»å‹â€çš„å…ƒç´ ï¼Œè€Œ String ä¸“é—¨ç”¨äºå¤„ç† UTF-8 ç¼–ç çš„æ–‡æœ¬æ•°æ®ã€‚åŠ¨æ€æ•°ç»„ Vec æä¾›æ›´çµæ´»çš„æ“ä½œï¼Œä½†åœ¨å¤„ç†æ–‡æœ¬æ—¶ï¼ŒString æä¾›äº†ä¸€äº›é¢å¤–çš„å­—ç¬¦ä¸²ç‰¹å®šåŠŸèƒ½ï¼Œä¾‹å¦‚å­—ç¬¦ä¸²è¿æ¥ã€åˆ‡ç‰‡ç­‰ã€‚é€‰æ‹©ä½¿ç”¨åŠ¨æ€æ•°ç»„ Vec è¿˜æ˜¯ String å–å†³äºå…·ä½“çš„éœ€æ±‚å’Œæ•°æ®ç±»å‹ã€‚

ä¸‹é¢çš„ä»£ç å±•ç¤ºäº† 5 ç§åˆ›å»ºåŠ¨æ€æ•°ç»„çš„ä¸åŒæ–¹å¼ã€‚

```rs
// 1.æ˜¾å¼å£°æ˜åŠ¨æ€æ•°ç»„ç±»å‹
let v1: Vec<i32> = Vec::new();

// 2.ç¼–è¯‘å™¨æ ¹æ®å…ƒç´ è‡ªåŠ¨æ¨æ–­ç±»å‹ï¼Œé¡»å°† v å£°æ˜ä¸º mut åï¼Œæ‰èƒ½è¿›è¡Œä¿®æ”¹ã€‚
let mut v2 = Vec::new();
v2.push(1);

// 3.ä½¿ç”¨å® vec! æ¥åˆ›å»ºæ•°ç»„ï¼Œæ”¯æŒåœ¨åˆ›å»ºæ—¶å°±ç»™äºˆåˆå§‹åŒ–å€¼
let v3 = vec![1, 2, 3];

// 4.ä½¿ç”¨ [åˆå§‹å€¼;é•¿åº¦] æ¥åˆ›å»ºæ•°ç»„ï¼Œé»˜è®¤å€¼ä¸º 0ï¼Œåˆå§‹é•¿åº¦ä¸º 3
let v4 = vec![0; 3];  // v4 = [0, 0, 0];

// 5.ä½¿ç”¨ from è¯­æ³•åˆ›å»ºæ•°ç»„
let v5 = Vec::from([0, 0, 0]);
assert_eq!(v4, v5);
```

åŠ¨æ€æ•°ç»„ Vector åœ¨å†…å­˜ä¸­çš„ç»“æ„æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå¦‚ä½•è¿›è¡ŒåŠ¨æ€è°ƒæ•´çš„ï¼Ÿ

```rs
fn main() {
    let mut v: Vec<i32> = vec![1, 2, 3, 4];
    //prints 4ï¼Œå³æ•°ç»„çš„åˆå§‹å®¹é‡æ˜¯ 4
    println!("v's capacity is {}", v.capacity());
    // æ‰“å°å†…å­˜åœ°å€
    println!("Address of v's first element: {:p}", &v[0]);

    v.push(5);
    //prints 8ï¼Œæ•°ç»„è¿›è¡Œæ‰©å®¹ï¼Œå®¹é‡å˜æˆ 8
    println!("v's capacity is {}", v.capacity());
    // æ‰“å°æ‰©å®¹åçš„å†…å­˜åœ°å€ï¼Œä¼šå‘ç°è·Ÿä¸Šé¢çš„åœ°å€å¹¶ä¸ç›¸åŒ
    println!("Address of v's first element: {:p}", &v[0]);
}
```

åˆå§‹æ—¶åŠ¨æ€æ•°ç»„ v çš„å®¹é‡æ˜¯ 4ï¼Œå †å†…å­˜ä¸­å­˜å‚¨æ•°å€¼ï¼Œæ ˆå†…å­˜ä¸­è®°å½•äº†å †å†…å­˜çš„åœ°å€æŒ‡é’ˆã€æ•°ç»„å®¹é‡åŠæ•°ç»„å¤§å°ï¼Œå½“æ·»åŠ æ–°å…ƒç´  5 æ—¶ï¼Œæ•°ç»„è¿›è¡Œæ‰©å®¹ï¼Œé‡æ–°ç”³è¯·ä¸€å— 2 å€å¤§å°çš„å†…å­˜ï¼ˆå³ 8ï¼‰ï¼Œå†å°†æ‰€æœ‰å…ƒç´ æ‹·è´åˆ°æ–°çš„å†…å­˜ä½ç½®ï¼ŒåŒæ—¶æ›´æ–°æŒ‡é’ˆæ•°æ®ï¼Œè¿™æ—¶æ•°ç»„å¤§å°æ˜¯ 5ï¼Œå®¹é‡å¤§å°æ˜¯ 8ã€‚

![](./assets/rust-vector-array.webp)

# Hashmap

Hashmap æ˜¯ Rust è¯­è¨€ä¸­çš„ä¸€ä¸ªé›†åˆç±»å‹ï¼Œç”¨äºå­˜å‚¨é”®ä¸å€¼ï¼ˆkey-valueï¼‰çš„å¯¹åº”å…³ç³»ã€‚æ¯ä¸ªé”® key æ˜ å°„åˆ°ä¸€ä¸ªå€¼ valueï¼Œé”®å¿…é¡»æ˜¯å”¯ä¸€çš„ã€‚è¿™ç§ç»“æ„å…è®¸æˆ‘ä»¬é€šè¿‡é”®å¿«é€Ÿæ£€ç´¢åˆ°å€¼ï¼Œè€Œä¸éœ€è¦éå†æ•´ä¸ªé›†åˆã€‚Hashmap çš„é«˜æ•ˆæ€§æ¥è‡ªäºå®ƒçš„æ•£åˆ—å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°èƒ½å¤Ÿå°†é”®è½¬æ¢æˆå­˜å‚¨ä½ç½®çš„ç´¢å¼•ï¼Œä»è€Œç›´æ¥è®¿é—®å†…å­˜ä¸­çš„ä½ç½®ï¼Œè¿™æ ·å°±å¤§å¤§åŠ å¿«äº†æŸ¥æ‰¾é€Ÿåº¦ã€‚

å¯ä»¥ä½¿ç”¨å¦‚ä¸‹ 2 ç§æ–¹å¼åˆ›å»º HashMapï¼Œå¦‚æœé¢„å…ˆçŸ¥é“è¦å­˜å‚¨çš„ key-value å¯¹ä¸ªæ•°ï¼Œå¯ä»¥åˆ›å»ºæŒ‡å®šå¤§å°çš„ HashMapï¼Œé¿å…é¢‘ç¹çš„å†…å­˜åˆ†é…å’Œæ‹·è´ï¼Œæå‡æ€§èƒ½ã€‚

```rs
// ç”±äº HashMap å¹¶æ²¡æœ‰åŒ…å«åœ¨ Rust çš„ prelude åº“ä¸­ï¼Œæ‰€ä»¥éœ€è¦æ‰‹åŠ¨å¼•å…¥
use std::collections::HashMap;
fn main() {
    // åˆ›å»ºä¸€ä¸ª HashMapï¼Œç”¨äºå­˜å‚¨å­¦ç”Ÿæˆç»©
    let mut student_grades = HashMap::new();
    student_grades.insert("Alice", 100);

    // åˆ›å»ºæŒ‡å®šå¤§å°çš„ HashMapï¼Œé¿å…é¢‘ç¹çš„å†…å­˜åˆ†é…å’Œæ‹·è´ï¼Œæå‡æ€§èƒ½ã€‚
    let mut student_grades2 = HashMap::with_capacity(3);
    student_grades2.insert("Alice", 100);
    student_grades2.insert("Bob", 99);
    student_grades2.insert("Eve", 59);
}
```

# æµç¨‹æ§åˆ¶

æµç¨‹æ§åˆ¶æ˜¯ç¼–å†™ç¨‹åºæ—¶è‡³å…³é‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒå†³å®šäº†ç¨‹åºçš„æ‰§è¡Œæµç¨‹ã€‚Rust åœ¨æµç¨‹æ§åˆ¶æ–¹é¢çš„è¯­æ³•è®¾è®¡ç®€æ´è€Œå¼ºå¤§ï¼Œå¸¸è§çš„æµç¨‹æ§åˆ¶è¯­å¥æœ‰ if è¡¨è¾¾å¼ã€for å¾ªç¯ã€while å¾ªç¯ã€loop å¾ªç¯ï¼Œè¿™äº›æ˜¯æ„å»ºç¨‹åºé€»è¾‘çš„é‡è¦å·¥å…·ï¼Œçµæ´»è¿ç”¨å®ƒä»¬å¯ä»¥ä½¿ç¨‹åºæ›´åŠ æ¸…æ™°å’Œé«˜æ•ˆã€‚

ä¸‹é¢çš„ä»£ç å±•ç¤ºäº† Rust ä¸­å¸¸è§çš„ 4 ç§æµç¨‹æ§åˆ¶å‘½ä»¤ï¼ŒåŸºæœ¬è¦†ç›–äº†ç¼–ç¨‹è¿‡ç¨‹ä¸­çš„ç»å¤§éƒ¨åˆ†åœºæ™¯ã€‚

```rs
fn main() {
    let condition = true;
    // if else è¯­æ³•
    if condition {
        // do something
    } else {
        // do something else
    }

    // for å¾ªç¯
    for i in 1..=5 {
        println!("{}", i);
    }

    // while å¾ªç¯
    let mut m = 1;
    while m <= 5  {
        println!("{}!", m);
        m = m + 1;
    }

    // loop å¾ªç¯
    let mut n = 1;
    loop {
        println!("{}!!", n);
        n = n + 1;
        if n > 5 {
            break;
        }
    }
}
```

# æ¨¡å¼åŒ¹é…

æ¨¡å¼åŒ¹é…å…è®¸æˆ‘ä»¬å°†ä¸€ä¸ª target å€¼ä¸ä¸€ç³»åˆ—çš„æ¨¡å¼ç›¸æ¯”è¾ƒï¼Œå¹¶æ ¹æ®ç›¸åŒ¹é…çš„æ¨¡å¼æ‰§è¡Œå¯¹åº”çš„è¡¨è¾¾å¼ã€‚Rust ä¸­å¸¸è§çš„æ¨¡å¼åŒ¹é…æœ‰ match å’Œ if let ä¸¤ç§ï¼Œè¿™é‡Œæˆ‘ä»¬ä»¥ match ä¸¾ä¾‹æ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯æ¨¡å¼åŒ¹é…ã€‚

```rs
match target {
    æ¨¡å¼1 => è¡¨è¾¾å¼1,
    æ¨¡å¼2 => {
        è¯­å¥1;
        è¯­å¥2;
        è¡¨è¾¾å¼2
    },
    _ => è¡¨è¾¾å¼3
}
```

è¿™é‡Œæˆ‘ä»¬å±•ç¤ºä¸‹ match æ¨¡å¼åŒ¹é…çš„å…¶ä»–ç”¨æ³•ï¼šæ¨¡å¼ç»‘å®šã€èµ‹å€¼ã€è§£æ„ã€‚if let ç®€å•æ¨¡å¼åŒ¹é…ï¼šç”¨æ¥å¤„ç†åªåŒ¹é…ä¸€ä¸ªæ¨¡å¼çš„å€¼è€Œå¿½ç•¥å…¶ä»–æ¨¡å¼çš„æƒ…å†µï¼Œå¯ä»¥è®©æˆ‘ä»¬çš„ä»£ç æ›´åŠ ç®€æ´ã€‚

```rs
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
    Square(f64),
}

fn calculate_area(shape: &Shape) -> f64 {
    match shape {
        // ä»åŒ¹é…çš„æ¨¡å¼ä¸­å–å‡ºç»‘å®šçš„å€¼ï¼Œå¦‚ radiuxã€widthã€side
        Shape::Circle(radius) => std::f64::consts::PI * radius * radius,
        Shape::Rectangle(width, height) => width * height,
        Shape::Square(side) => side * side,
    }
}
struct Point {
    x: i32,
    y: i32,
}

fn process_point(point: Point) {
    match point {
        Point { x: 0, y: 0 } => println!("åæ ‡åœ¨åŸç‚¹"),
        Point { x, y } => println!("åæ ‡åœ¨ ({}, {})", x, y),
    }
}

fn main() {
    let circle = Shape::Circle(3.0);
    let rectangle = Shape::Rectangle(4.0, 5.0);
    let square = Shape::Square(2.0);

    // 1ã€è°ƒç”¨å‡½æ•°ï¼Œè¾“å‡ºå„å½¢çŠ¶çš„é¢ç§¯
    println!("åœ†å½¢çš„é¢ç§¯ï¼š{}", calculate_area(&circle));
    println!("çŸ©å½¢çš„é¢ç§¯ï¼š{}", calculate_area(&rectangle));
    println!("æ­£æ–¹å½¢çš„é¢ç§¯ï¼š{}", calculate_area(&square));

    // 2ã€match æ¨¡å¼åŒ¹é…è¿›è¡Œèµ‹å€¼
    let area = match circle {
        Shape::Circle(radius) => std::f64::consts::PI * radius * radius,
        Shape::Rectangle(width, height) => width * height,
        Shape::Square(side) => side * side,
    };
    println!("åœ†å½¢çš„é¢ç§¯ï¼š{}", area);

    // 3ã€è§£æ„ç»“æ„ä½“
    let point1 = Point { x: 0, y: 0 };
    let point2 = Point { x: 3, y: 7 };
    process_point(point1);
    process_point(point2);

		// 4ã€if let ç®€å•åŒ¹é…
    let some_u8_value = Some(3u8);
    match some_u8_value {
        Some(3) => println!("three"),
        // è¿™é‡Œè¿˜è¦è€ƒè™‘é™¤ 3 ä»¥å¤–çš„å…¶ä»–å€¼ï¼Œä»¥åŠ None å€¼
        _ => (),
    }

    // åªåŒ¹é…æ•°å€¼ 3 å³å¯
    if let Some(3) = some_u8_value {
        println!("three");
    }
}
```

# æ–¹æ³•

æ–¹æ³•ï¼šæ˜¯ä¸ç»“æ„ä½“ structs æˆ–æšä¸¾ enums æˆ–ç‰¹å¾å¯¹è±¡ trait ç­‰ç‰¹å®šç±»å‹ç›¸å…³è”çš„å‡½æ•°ï¼Œå®ƒä»¬å…è®¸ä½ åœ¨è¿™äº›ç±»å‹ä¸Šå®šä¹‰è¡Œä¸ºï¼Œå¹¶ä¸”æ”¯æŒåƒè°ƒç”¨æ™®é€šå‡½æ•°ä¸€æ ·è°ƒç”¨è¯¥è¡Œä¸ºã€‚

æ–¹æ³•ä¸å‡½æ•°ç±»ä¼¼ï¼šå®ƒä»¬ä½¿ç”¨ fn å…³é”®å­—å’Œåç§°å£°æ˜ï¼Œå¯ä»¥æ‹¥æœ‰å‚æ•°å’Œè¿”å›å€¼ï¼Œä»¥åŠå¯¹åº”çš„å‡½æ•°ä½“é€»è¾‘ã€‚ä¸è¿‡æ–¹æ³•ä¸å‡½æ•°æ˜¯ä¸åŒçš„ï¼Œå› ä¸ºæ–¹æ³•é€šè¿‡ impl å…³é”®å­—åœ¨ç»“æ„ä½“æˆ–æšä¸¾çš„ä¸Šä¸‹æ–‡ä¸­å®šä¹‰ï¼Œå¹¶ä¸”å®ƒä»¬ç¬¬ä¸€ä¸ªå‚æ•°æ€»æ˜¯&selfï¼Œä»£è¡¨è°ƒç”¨è¯¥æ–¹æ³•çš„ç»“æ„ä½“å®ä¾‹ã€‚

è¯¥ä¾‹å­å®šä¹‰äº†ä¸€ä¸ª Rectangle ç»“æ„ä½“ï¼Œå¹¶ä¸”åœ¨å…¶ä¸Šå®šä¹‰äº†ä¸€ä¸ª area æ–¹æ³•ï¼Œç”¨äºè®¡ç®—è¯¥çŸ©å½¢çš„é¢ç§¯ã€‚å¹¶åœ¨ main å‡½æ•°ä¸­è°ƒç”¨è¯¥æ–¹æ³•ã€‚

```rs
// ç»“æ„ä½“å®šä¹‰
struct Rectangle {
    width: u32,
    height: u32,
}

// impl Rectangle {} è¡¨ç¤ºä¸º Rectangle å®ç°æ–¹æ³• (impl æ˜¯å®ç° implementation çš„ç¼©å†™)
impl Rectangle {
    // area æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸º &selfï¼Œä»£è¡¨ç»“æ„ä½“å®ä¾‹æœ¬èº«
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        // è¿™é‡Œè°ƒç”¨ç»“æ„ä½“çš„ area æ–¹æ³•
        rect1.area()
    );
}
```

æ–¹æ³•å’Œå‡½æ•°ä¹‹é—´çš„ä¸»è¦åŒºåˆ«åœ¨äºå®ƒä»¬ä¸ç±»å‹çš„å…³ç³»ä»¥åŠè°ƒç”¨æ–¹å¼ã€‚

æ–¹æ³•ä¸ç‰¹å®šçš„ç±»å‹ï¼ˆç»“æ„ä½“ã€æšä¸¾ã€trait ç­‰ï¼‰å…³è”ï¼›åœ¨ç±»å‹çš„ impl å—å†…å®šä¹‰ï¼Œä½¿ç”¨ self å‚æ•°æ¥è¡¨ç¤ºè°ƒç”¨è¯¥æ–¹æ³•çš„å®ä¾‹ï¼›ä½¿ç”¨ç‚¹è¿ç®—ç¬¦æ¥è°ƒç”¨ï¼Œç±»ä¼¼äºé¢å‘å¯¹è±¡è¯­è¨€ä¸­çš„å¯¹è±¡æ–¹æ³•ã€‚

è€Œå‡½æ•°åˆ™ä¸ç‰¹å®šç±»å‹æ— å…³ï¼Œæ˜¯ç‹¬ç«‹å­˜åœ¨çš„ï¼›å¯åœ¨ä»»ä½•åœ°æ–¹å®šä¹‰ï¼Œæ²¡æœ‰ self å‚æ•°ï¼Œå› ä¸ºå®ƒä»¬ä¸ä¸ç‰¹å®šå®ä¾‹ç›¸å…³ï¼›ç›´æ¥é€šè¿‡å‡½æ•°åè°ƒç”¨ã€‚

## æšä¸¾ä¸­å®šä¹‰æ–¹æ³•åŠä½¿ç”¨

è·Ÿç»“æ„ä½“ç±»ä¼¼ï¼Œå…·ä½“çœ‹ä¸‹ä¸‹é¢çš„ä»£ç 

```rs
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        match &self {
            Message::Quit => println!("é€€å‡º"),
            Message::Move { x, y } => println!("ç§»åŠ¨åˆ° ({},{})", x, y),
            Message::Write(text) => println!("å†™å…¥{}", text),
            Message::ChangeColor(r, g, b) => println!("æ”¹å˜é¢œè‰²ä¸º ({}, {}, {})", r, g, b),
        }
    }
}

fn main() {
    let m = Message::Move { x: 1, y: 2 };
		// è°ƒç”¨æšä¸¾æ–¹æ³• call
    m.call();

    let n = Message::Write(String::from("hello"));
    n.call();
}
```

# æ³›å‹ï¼ˆgenericsï¼‰

æ³›å‹ï¼ˆgenericsï¼‰ï¼šæ˜¯ä¸€ç§å¼ºå¤§çš„ç¼–ç¨‹ç‰¹æ€§ï¼Œå…è®¸ç¼–å†™å¯é‡ç”¨ã€é€šç”¨çš„ä»£ç ï¼Œè€Œä¸å¿…é’ˆå¯¹ç‰¹å®šçš„æ•°æ®ç±»å‹è¿›è¡Œç¡¬ç¼–ç ã€‚æ³›å‹çš„æ ¸å¿ƒæ€æƒ³æ˜¯å‚æ•°åŒ–ç±»å‹ï¼Œå³é€šè¿‡åœ¨å®šä¹‰æ—¶ä½¿ç”¨å ä½ç¬¦æ¥è¡¨ç¤ºæ•°æ®ç±»å‹ã€‚ä¾‹å¦‚ï¼Œä¹‹å‰ç« èŠ‚ç”¨åˆ°çš„ Vec<T>ã€HashMap<K,V>ã€Option<T>æ•°æ®ç±»å‹ï¼Œä½¿ç”¨<T>è¡¨ç¤ºä¸€ä¸ªæ³›å‹å‚æ•°ï¼ˆä¹Ÿå¯ä»¥ç”¨å…¶ä»–å­—ç¬¦æ›¿ä»£ï¼Œå¦‚ Kã€Vï¼‰ï¼Œå…¶ä¸­ T å¯ä»¥åœ¨å®é™…ä½¿ç”¨æ—¶æ›¿æ¢ä¸ºä»»ä½•å…·ä½“çš„æ•°æ®ç±»å‹ã€‚è¿™æ ·çš„çµæ´»æ€§ä½¿å¾—ä»£ç æ›´åŠ é€šç”¨ã€å¯è¯»æ€§æ›´å¼ºã€‚

å‡å¦‚æˆ‘ä»¬æœ‰ä¸€ä¸ªå‡½æ•° largest å¯ä»¥ç”¨æ¥æŸ¥æ‰¾ i32 ç±»å‹æ•°ç»„ä¸­çš„æœ€å¤§å…ƒç´ ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦å®ƒæ”¯æŒ i64 ç±»å‹çš„æ•°ç»„ï¼Œæ€ä¹ˆåŠï¼Ÿå½“ç„¶æ–°å¢ä¸€ä¸ªå‚æ•°ä¸º i64 ç±»å‹çš„å‡½æ•°ä¹Ÿå¯ä»¥ï¼Œé™¤äº†ç±»å‹ä¸åŒå¤–ï¼Œå…¶ä»–çš„é€»è¾‘è·Ÿä¸Šä¸€ä¸ªå‡½æ•°éƒ½ä¸€æ ·ï¼Œä½†æœªå…å¤ªç¹çã€‚

```rs
// æŸ¥æ‰¾ i32 ç±»å‹æ•°ç»„çš„æœ€å¤§å…ƒç´ 
fn largest_for_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

// æŸ¥æ‰¾ i64 ç±»å‹æ•°ç»„çš„æœ€å¤§å…ƒç´ ï¼Œé™¤äº†å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹ä¸åŒå¤–ï¼Œå…¶ä»–è·Ÿ
// ä¸Šä¸€ä¸ªå‡½æ•°å®Œå…¨ä¸€æ ·
fn largest_for_i64(list: &[i64]) -> i64 {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

é‚£æœ‰ä»€ä¹ˆå¥½çš„åŠæ³•å—ï¼Ÿå½“ç„¶ï¼Œæ³›å‹å¯ä»¥å¸®æˆ‘ä»¬è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å°†å…·ä½“ç±»å‹æŠ½è±¡ä¸ºæ³›å‹ Tï¼Œåªè¦å®ƒé‡Œé¢çš„å…ƒç´ æ”¯æŒå¤§å°æ¯”è¾ƒå³å¯ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æŠŠä¸Šé¢çš„ 2 ä¸ªå‡½æ•°æŠ½è±¡æˆ 1 ä¸ªæ³›å‹å‡½æ•°ã€‚

```rs
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        // è¿™é‡Œåªæ˜¯åšç¤ºæ„è¯´æ˜ï¼Œå®é™…ä»£ç éœ€è¦å¢åŠ æ³›å‹çº¦æŸ
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

# Trait ç‰¹æ€§

Trait ç‰¹å¾ï¼šä¸€ä¸ªç±»å‹çš„è¡Œä¸ºç”±å…¶å¯ä¾›è°ƒç”¨çš„æ–¹æ³•æ„æˆï¼Œå¦‚æœå¯ä»¥å¯¹ä¸åŒç±»å‹è°ƒç”¨ç›¸åŒçš„æ–¹æ³•çš„è¯ï¼Œè¿™äº›ç±»å‹å°±å¯ä»¥å…±äº«ç›¸åŒçš„è¡Œä¸ºäº†ã€‚Trait ç‰¹å¾æ˜¯ä¸€ç§å°†æ–¹æ³•ç­¾åç»„åˆèµ·æ¥çš„æœºåˆ¶ï¼Œç›®çš„æ˜¯æ„å»ºä¸€ä¸ªå®ç°æŸäº›ç›®çš„æ‰€å¿…éœ€çš„è¡Œä¸ºçš„é›†åˆã€‚æ€»çš„æ¥è¯´ï¼Œå®ƒæ˜¯å®šä¹‰ç±»å‹çš„å…±äº«è¡Œä¸ºå¹¶å®ç°ä»£ç çš„æŠ½è±¡ã€‚

è¿™é‡Œæ¼”ç¤ºäº† Trait ç‰¹å¾å¦‚ä½•å®šä¹‰ï¼Œå¹¶åœ¨ç»“æ„ä½“ä¸Šå®ç°çš„ç›¸å…³é€»è¾‘ã€‚

```rs
// trait å…³é”®å­— + MigrateBird ç‰¹å¾å
trait MigrateBird {
    // å®šä¹‰è¯¥ç‰¹å¾çš„æ–¹æ³•ï¼Œå‚æ•°å¿…é¡»åŒ…å«&selfï¼Œå› ä¸ºå®ƒæ˜¯è¯¥ç±»å‹ä¸Šçš„è¡Œä¸º
    fn migrate(&self) -> String;
}

// å®šä¹‰å¤§é›ç»“æ„ä½“
struct WildGoose {
     color : String,
}

// ä¸º wild_goose ç±»å‹å®ç° migrate_bird ç‰¹å¾
impl MigrateBird for WildGoose {
     fn migrate(&self) -> String {
         "Geese fly in a V-shaped formation".to_string()
     }
}
```

æ³¨æ„ï¼šå¦‚æœ Trait ç‰¹å¾æ–¹æ³•æ²¡æœ‰é»˜è®¤å®ç°ï¼Œåˆ™æ–¹æ³•å®šä¹‰ä»¥åˆ†å·;ç»“å°¾ï¼Œå³åªæœ‰æ–¹æ³•ç­¾åï¼Œæ²¡æœ‰{}æ–¹æ³•ä½“ï¼Œå› ä¸ºå…·ä½“çš„å®ç°äº¤ç”±å„ç±»å‹è´Ÿè´£ã€‚

ä»€ä¹ˆæ˜¯ Trait ç‰¹å¾çš„é»˜è®¤å®ç°ï¼Ÿ

Trait æ˜¯å…±äº«çš„è¡Œä¸ºï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç»™å®ƒèµ‹äºˆé»˜è®¤è¡Œä¸ºï¼Œè€Œç±»å‹åœ¨å¿…è¦çš„æ—¶å€™è¿›è¡Œè¦†ç›–ï¼Œå¦åˆ™å°±ä½¿ç”¨é»˜è®¤çš„è¡Œä¸ºã€‚ä¸‹é¢çš„ä»£ç å±•ç¤ºäº†å¦‚ä½•å®šä¹‰é»˜è®¤è¡Œä¸ºã€‚

```rs
// å®šä¹‰ç‰¹å¾ï¼Œå¹¶èµ‹äºˆé»˜è®¤å®ç° default_migrate
trait MigrateBird {
    fn default_migrate(&self) {
        println!("i am flying to the warm south");
    }
}

struct Swallow {
    color : String,
}

// è¿™é‡Œç›´æ¥ä½¿ç”¨é»˜è®¤çš„å®ç°
impl MigrateBird for Swallow {}

fn main() {
    let small_swallow = Swallow {
        color : String::from("black")
    };
    small_swallow.default_migrate();
}
```

# æ³›å‹å•æ€åŒ–ï¼ˆmonomorphizationï¼‰

æ˜¯ä¸€ç§ç¼–è¯‘ä¼˜åŒ–æŠ€æœ¯ï¼Œå®ƒé€šè¿‡å¡«å……ç¼–è¯‘æ—¶ä½¿ç”¨çš„å…·ä½“ç±»å‹ï¼Œå°†é€šç”¨ä»£ç è½¬æ¢ä¸ºç‰¹å®šä»£ç ã€‚ä¸åˆ›å»ºæ³›å‹å‡½æ•°çš„æ­¥éª¤ç›¸åï¼Œç¼–è¯‘å™¨å¯»æ‰¾æ‰€æœ‰æ³›å‹ä»£ç è¢«è°ƒç”¨çš„ä½ç½®å¹¶ä½¿ç”¨æ³›å‹ä»£ç é’ˆå¯¹å…·ä½“ç±»å‹ç”Ÿæˆä»£ç ã€‚

é’ˆå¯¹ä¸ŠèŠ‚ä¸­æ³›å‹å‡½æ•° largestï¼Œå‚æ•°ç±»å‹ä¸º&Tï¼Œè¿™æ · i32ã€i64 æˆ–è€…å…¶ä»–ç±»å‹éƒ½å¯ä»¥è°ƒç”¨è¯¥å‡½æ•°ã€‚

```rs
// T å¯ä»¥ä»£è¡¨ä»»ä½•ä¸€ç§ç±»å‹
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];
    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let arr1: [i32; 3] = [1, 2, 3];
    largest(&arr1);
    let arr2: [i64; 3] = [1, 2, 3];
    largest(&arr2);
}
```

ä½†æ˜¯åœ¨ç¼–è¯‘é˜¶æ®µï¼Œå¯¹äºæ¯ç§ä½¿ç”¨ä¸åŒç±»å‹çš„æ³›å‹å‡½æ•°çš„æƒ…å†µï¼Œç¼–è¯‘å™¨åˆéƒ½ä¼šç”Ÿæˆä¸€ä¸ªå…·ä½“çš„å‡½æ•°ï¼Œä»¥ä¾¿è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚å•æ€åçš„ä»£ç ç±»ä¼¼äºè¿™æ ·ã€‚

```rs
// é‡æ–°å®ä¾‹åŒ–ä¸º i32 ç±»å‹çš„å‡½æ•°
fn largest_for_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];
    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// é‡æ–°å®ä¾‹åŒ–ä¸º i64 ç±»å‹çš„å‡½æ•°
fn largest_for_i64(list: &[i64]) -> i64 {
    let mut largest = list[0];
    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }
    largest
}
```

æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ³›å‹æ¥ç¼–å†™ä¸é‡å¤çš„ä»£ç ï¼Œè€Œ Rust å°†ä¼šä¸ºæ¯ä¸€ä¸ªå®ä¾‹ç¼–è¯‘å…¶ç‰¹å®šç±»å‹çš„ä»£ç ã€‚è¿™æ„å‘³ç€åœ¨ä½¿ç”¨æ³›å‹æ—¶æ²¡æœ‰è¿è¡Œæ—¶å¼€é”€ï¼›å½“ä»£ç è¿è¡Œï¼Œå®ƒçš„æ‰§è¡Œæ•ˆç‡å°±è·Ÿå¥½åƒæ‰‹å†™æ¯ä¸ªå…·ä½“å®šä¹‰çš„é‡å¤ä»£ç ä¸€æ ·ã€‚è¿™ä¸ªå•æ€åŒ–è¿‡ç¨‹æ­£æ˜¯ Rust æ³›å‹åœ¨è¿è¡Œæ—¶æå…¶é«˜æ•ˆçš„åŸå› ã€‚

## ç‰¹å¾çº¦æŸï¼ˆTrait boundï¼‰

æˆ‘ä»¬å…ˆçœ‹ä¸‹ Trait æ˜¯å¦‚ä½•ä½œä¸ºå‚æ•°ä¼ é€’çš„ï¼Œå›åˆ°ä¸ŠèŠ‚å€™é¸Ÿ MigrateBird çš„ä¾‹å­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå‚æ•°ç±»å‹ä¸º MigrateBird çš„ fly æ–¹æ³•ï¼Œå¦‚ä¸‹ï¼š

```rs
// trait ç‰¹å¾
trait MigrateBird {
    fn migrate(&self) -> String;
}

// ä¸ºå¤§é›å®ç° Trait ç‰¹æ€§çš„ migrate æ–¹æ³•
impl MigrateBird for WildGoose {
    fn migrate(&self) -> String {
        "Geese fly in a V-shaped formation".to_string()
    }
}

// ä¸ºç‡•å­å®ç° Trait ç‰¹æ€§çš„ migrate æ–¹æ³•
impl MigrateBird for Swallow {
    fn migrate(&self) -> String {
        "swallow fly fast, but have to rest frequently".to_string()
    }
}

fn fly(item: impl MigrateBird) {
		println!("i am flying to the warm south");
}
```

å½“ç„¶ï¼Œå¯¹äº fly æ–¹æ³•ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ç”¨ Trait bound çš„æ–¹å¼å®ç°ï¼Œè¿™æ ·ï¼Œåªæœ‰æ˜¯ MigrateBird ç±»å‹çš„å‚æ•°ï¼Œæ‰å¯ä»¥è°ƒç”¨è¯¥å‡½æ•°ï¼Œæ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬æŠŠå‚æ•°çš„æ³›å‹ç±»å‹é™åˆ¶ä¸º MigrateBird ç±»å‹ã€‚

```rs
fn fly<T: MigrateBird>(item: T) {
		println!("i am flying to the warm south");
}
```

# å…³è”ç±»å‹

åœ¨ Rust ä¸­ï¼Œå…³è”ç±»å‹å…è®¸æˆ‘ä»¬åœ¨ trait ä¸­ä½¿ç”¨ç±»å‹å‚æ•° typeï¼Œè¯¥ç±»å‹å¯ä»¥åœ¨å®ç° trait çš„æ—¶å€™å…·ä½“åŒ–ã€‚è¿™ä½¿å¾— trait èƒ½å¤Ÿä¸ä¸åŒçš„å…·ä½“ç±»å‹ä¸€èµ·ä½¿ç”¨ï¼Œè€Œä¸éœ€è¦åœ¨ trait ä¸­æå‰æŒ‡å®šå…·ä½“çš„ç±»å‹ã€‚é€šè¿‡å…³è”ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ trait ä¸­ä½¿ç”¨æŠ½è±¡çš„ç±»å‹ï¼Œè€Œåœ¨å®ç° trait æ—¶å†å…·ä½“æŒ‡å®šè¿™äº›ç±»å‹ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ä¸åŒçš„ç±»å‹ä¸Šå…±äº«ç›¸åŒçš„è¡Œä¸ºï¼Œä»è€Œå¢åŠ äº† trait çš„çµæ´»æ€§ã€‚

å…³è”ç±»å‹æ˜¯åœ¨ç‰¹å¾å®šä¹‰çš„è¯­å¥å—ä¸­ï¼Œç”³æ˜ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ç‰¹å¾çš„æ–¹æ³•ç­¾åä¸­ä½¿ç”¨è¯¥ç±»å‹ï¼š

```rs
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

ä»¥ä¸Šæ˜¯æ ‡å‡†åº“ä¸­çš„è¿­ä»£å™¨ç‰¹å¾ Iteratorï¼Œå®ƒæœ‰ä¸€ä¸ª Item å…³è”ç±»å‹ï¼Œç”¨äºæ›¿ä»£éå†çš„å€¼çš„ç±»å‹ã€‚åŒæ—¶ï¼Œnext æ–¹æ³•ä¹Ÿè¿”å›äº†ä¸€ä¸ª Item ç±»å‹ï¼Œä¸è¿‡ä½¿ç”¨ Option æšä¸¾è¿›è¡Œäº†åŒ…è£¹ï¼Œå‡å¦‚è¿­ä»£å™¨ä¸­çš„å€¼æ˜¯ i32 ç±»å‹ï¼Œé‚£ä¹ˆè°ƒç”¨ next æ–¹æ³•å°±å°†è·å–ä¸€ä¸ª Option<i32> çš„å€¼ã€‚

```rs
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
    }
}
```

é€šè¿‡å¦‚ä¸Šä»£ç ï¼Œæˆ‘ä»¬åœ¨ Counter çš„å®ç°ä¸­æŒ‡å®šäº† Item çš„å…·ä½“ç±»å‹ u32ï¼Œè¿™ä¹Ÿæ˜¯ next å‡½æ•°çš„è¿”å›å€¼ Self::Item å¯¹åº”çš„ç±»å‹ã€‚

æ˜¯å¦å¯ä»¥é€šè¿‡æ³›å‹å‚æ•°è¾¾åˆ°ç›¸åŒçš„æ•ˆæœï¼Œå…³è”ç±»å‹è·Ÿæ³›å‹å‚æ•°ç›¸æ¯”ï¼Œå®ƒä»¬çš„é€‚ç”¨åœºæ™¯æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

é€šè¿‡åœ¨ trait ä¸­ä½¿ç”¨æ³›å‹å‚æ•°ï¼Œå¯ä»¥å®ç°ä¸å…³è”ç±»å‹ç±»ä¼¼çš„çµæ´»æ€§ã€‚ä»¥ä¸‹æ˜¯ä½¿ç”¨æ³›å‹å‚æ•°çš„ç¤ºä¾‹ï¼š

```rs
pub trait Iterator<T> {

    fn next(&mut self) -> Option<T>;
}
```

å…³è”ç±»å‹ç›¸å¯¹äºæ³›å‹å‚æ•°ç›¸æ¯”ï¼Œè¯­æ³•æ›´ç®€æ´ï¼šä½¿ç”¨å…³è”ç±»å‹æ—¶ï¼Œä¸éœ€è¦åœ¨æ¯ä¸ª impl è¯­å¥ä¸­æŒ‡å®šå…·ä½“çš„ç±»å‹å‚æ•°ï¼ˆå¦‚ impl Iterator<u32> for Counter {â€¦}ï¼‰ï¼Œè€Œæ˜¯åœ¨ trait ä¸­å®šä¹‰å…³è”ç±»å‹ï¼Œå°¤å…¶å½“æ³›å‹å‚æ•°è¾ƒå¤šæ—¶ï¼Œä½¿å¾—ä»£ç æ›´åŠ æ¸…æ™°ç®€æ´ï¼Œæå‡ä»£ç å¯è¯»æ€§ã€‚

é€šå¸¸æƒ…å†µä¸‹ï¼Œæ³›å‹å‚æ•°æ›´é€‚ç”¨äºå‡½æ•°ä¸­ï¼Œå½“å‡½æ•°éœ€è¦é€‚ç”¨äºå¤šä¸ªä¸åŒç±»å‹æ—¶ï¼Œä½¿ç”¨æ³›å‹å‚æ•°å¯ä»¥æä¾›æ›´å¤§çš„çµæ´»æ€§ã€‚è€Œå…³è”ç±»å‹æ›´é€‚åˆä¸ trait ç›¸å…³çš„ç±»å‹æŠ½è±¡ï¼šå½“ trait éœ€è¦å®šä¹‰ä¸€ä¸ªä¸ trait ç›¸å…³çš„ç±»å‹ï¼Œä¸”è¿™ä¸ªç±»å‹åœ¨å®ç° trait æ—¶æ‰èƒ½ç¡®å®šå…·ä½“ç±»å‹æ—¶ï¼Œä½¿ç”¨å…³è”ç±»å‹ä¼šæ›´åŠ åˆé€‚ã€‚

å› æ­¤ï¼Œé€‰æ‹©ä½¿ç”¨æ³›å‹å‚æ•°è¿˜æ˜¯å…³è”ç±»å‹å–å†³äºå…·ä½“çš„éœ€æ±‚å’Œä»£ç ç»“æ„ï¼Œä»¥åŠå¯¹çµæ´»æ€§å’ŒæŠ½è±¡çº§åˆ«çš„éœ€æ±‚ã€‚

# é”™è¯¯å¤„ç†

Rust ä¸­çš„é”™è¯¯ä¸»è¦åˆ†ä¸º 2 ç±»ï¼Œä¸å¯æ¢å¤é”™è¯¯ panic å’Œå¯æ¢å¤é”™è¯¯ Resultã€‚

Panic æ˜¯ä¸€ç§éæ­£å¸¸çš„ç¨‹åºç»ˆæ­¢ï¼Œé€šå¸¸è¡¨ç¤ºå‘ç”Ÿäº†æ— æ³•æ¢å¤çš„é”™è¯¯ï¼Œä¾‹å¦‚æ•°ç»„è¶Šç•Œã€é™¤é›¶ç­‰ã€‚åœ¨ Rust ä¸­ï¼ŒPanic å¯ä»¥é€šè¿‡ panic! å®æ¥æ˜¾å¼è§¦å‘ã€‚å½“ panic å‘ç”Ÿæ—¶ï¼Œç¨‹åºä¼šæ‰“å°é”™è¯¯ä¿¡æ¯ï¼Œå¹¶åœ¨æ ˆå±•å¼€ï¼ˆstack unwindingï¼‰è¿‡ç¨‹ä¸­æ¸…ç†èµ„æºï¼Œæœ€ç»ˆé€€å‡ºç¨‹åºã€‚

Result æ˜¯ä¸€ç§æ›´ä¸ºæ­£å¸¸å’Œå¯æ§çš„é”™è¯¯å¤„ç†æ–¹å¼ï¼Œä¾‹å¦‚æ–‡ä»¶æ“ä½œã€ç½‘ç»œè¯·æ±‚ç­‰å¯èƒ½å‘ç”Ÿé”™è¯¯çš„åœºæ™¯ã€‚è¿™äº›æ“ä½œå¯ä»¥è¿”å› Result<T, E> ç±»å‹å¹¶äº¤ç”±å¼€å‘è€…å¤„ç†ï¼Œå…¶ä¸­ T æ˜¯æˆåŠŸæ—¶çš„è¿”å›ç±»å‹ï¼ŒE æ˜¯é”™è¯¯æ—¶çš„è¿”å›ç±»å‹ã€‚

ä¸‹é¢çš„ä»£ç æˆ‘ä»¬åˆ†åˆ«å±•ç¤ºäº† panic é”™è¯¯å’Œ Result<T, E>é”™è¯¯ã€‚å…¶ä¸­ T å’Œ E æ˜¯æ³›å‹ç±»å‹å‚æ•°ï¼ŒT ä»£è¡¨æˆåŠŸæ—¶è¿”å›çš„æ•°æ®ç±»å‹ï¼Œè€Œ E ä»£è¡¨å¤±è´¥æ—¶è¿”å›çš„é”™è¯¯ç±»å‹ã€‚ç”±äº Result é¢„å¯¼å…¥æ¨¡å—ï¼ˆpreludeï¼‰å·²ç»åŒ…å«äº† Result æšä¸¾åŠå…¶æˆå‘˜ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸­ä¸éœ€è¦æ˜¾å¼æŒ‡å®šå‰ç¼€ Result::ï¼Œå¦‚ Result::Okã€Result::Errï¼Œå¯ç›´æ¥ä½¿ç”¨ OK æˆ– Err

```rs
/*
 * Result çš„å®šä¹‰å¦‚ä¸‹ï¼Œ
 *
 * enum Result<T, E> {
 *    Ok(T),
 *	  Err(E),
 * }
 */

// ä¸¤æ•°ç›¸é™¤
fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Cannot divide by zero!"))
    } else {
        Ok(a / b)
    }
}

// ä¸å¯æ¢å¤é”™è¯¯
fn main1() {
    // äººä¸ºåˆ¶é€ ä¸€ä¸ª panic çš„åœºæ™¯ï¼Œç¨‹åºè¿è¡Œåˆ°æ­¤å¤„ä¼šä¸­æ–­ï¼Œä¸å†å¾€ä¸‹æ‰§è¡Œ
    panic!("This is a panic situation!");
}

// å¯æ¢å¤é”™è¯¯ï¼Œä½¿ç”¨ Result ç±»å‹æ¥å¤„ç†æ½œåœ¨çš„é”™è¯¯
fn main2() {

    // divide(1, 0) è¿”å›å€¼ä¸º Result ç±»å‹ï¼Œè¿™é‡Œé€šè¿‡ match è¿›è¡Œæ¨¡å¼åŒ¹é…ï¼Œåˆ†åˆ«å¤„ç†æˆåŠŸå’Œå¤±è´¥è¿™ 2 ç§æƒ…å†µ
    match divide(1, 0) {
        Ok(result) => println!("Result: {}", result),
        Err(err) => println!("Error: {}", err),
    }
}
```

## é”™è¯¯äº¤ç»™ä¸Šå±‚è°ƒç”¨è€…æ¥å¤„ç†ï¼Œé”™è¯¯ä¼ æ’­

å¦‚æœ method_a è°ƒç”¨ method_b æ—¶ï¼Œé™¤äº† method_b ä¸­å¤„ç†é”™è¯¯å¤–ï¼Œè¿˜å¯ä»¥é€‰æ‹©è®©è°ƒç”¨è€… method_a çŸ¥é“è¿™ä¸ªé”™è¯¯å¹¶å†³å®šè¯¥å¦‚ä½•å¤„ç†ï¼Œè¿™ç§°ä¸º ä¼ æ’­ï¼ˆpropagatingï¼‰é”™è¯¯ï¼Œè¿™æ ·èƒ½æ›´å¥½åœ°æ§åˆ¶ä»£ç è°ƒç”¨ï¼Œå› ä¸ºè°ƒç”¨è€… method_a å¯èƒ½æ‹¥æœ‰æ›´å¤šçš„ä¸Šä¸‹æ–‡ä¿¡æ¯æˆ–é€»è¾‘æ¥å†³å®šåº”è¯¥å¦‚ä½•å¤„ç†é”™è¯¯ã€‚è¯·çœ‹ä¸‹é¢é”™è¯¯ä¼ æ’­çš„ä»£ç ç¤ºæ„

```rs
use std::io;
use std::io::Read;
use std::fs::File;
// æ‰“å¼€å¹¶è¯»å–æ–‡ä»¶å†…å®¹ï¼Œè¿™é‡Œè¿”å›å€¼ä¸º Result ç±»å‹ï¼Œä¸ç®¡æ­£å¸¸è¿˜æ˜¯é”™è¯¯ï¼Œéƒ½å¯ä»¥
// ä¼ æ’­ç»™ä¸Šå±‚è°ƒç”¨è€… main å‡½æ•°
fn read_file_contents(file_path: &str) -> Result<String, io::Error> {
    // å°è¯•æ‰“å¼€æ–‡ä»¶
    let my_file: Result<File, io::Error> = File::open(file_path);

    // é‡‡ç”¨æ¨¡å¼åŒ¹é…ï¼Œå¦‚æœæ‰“å¼€æˆåŠŸï¼Œåˆ™å°†æ–‡ä»¶å¥æŸ„ç»‘å®šåˆ° file å˜é‡ï¼Œ
    // å¦åˆ™é‡‡ç”¨ Return æ˜¾å¼è¿”å›é”™è¯¯ä¿¡æ¯ï¼Œäº¤ç”±ä¸Šå±‚è°ƒç”¨è€… main å‡½æ•°å¤„ç†
    let mut file = match my_file {
        // ç­‰åŒäº Result::Ok(file)
        Ok(my_file) => my_file,
        Err(e) => return Err(e),
    };

    let mut contents = String::new();

    // è¿™æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæ¨¡å¼åŒ¹é…åç›´æ¥è¿”å›å¯¹åº”çš„å€¼
    // å¦‚æœè¯»å–æˆåŠŸï¼Œåˆ™è¿”å› Ok(contents)ï¼Œåä¹‹ï¼Œè¿”å› Err(e)ï¼Œä¸Šå±‚è°ƒç”¨è€… main
		// å‡½æ•°å¤„ç†å‡½æ•°è°ƒç”¨çš„æœ€ç»ˆç»“æœ
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}

fn main() {
	// è¿™é‡Œå¤„ç†å‡½æ•°çš„è°ƒç”¨ç»“æœ
	match read_file_contents("example.txt") {
		Ok(contents) => println!("File contents: {}", contents),
		// ä¸Šå±‚è°ƒç”¨è€…å†³å®šåªæ‰“å°é”™è¯¯ä¿¡æ¯ï¼Œè€Œä¸æ˜¯ä¸­æ–­ç¨‹åºæ‰§è¡Œ
		Err(err) => eprintln!("Error reading file: {}", err),
	}
}
```

# å®ï¼ˆMacroï¼‰

å®ï¼ˆMacroï¼‰æ˜¯ä¸€ç§å…ƒç¼–ç¨‹ï¼ˆmetaprogrammingï¼‰çš„å·¥å…·ï¼Œä½¿å¾—å¼€å‘è€…èƒ½å¤Ÿç¼–å†™èƒ½å¤Ÿç”Ÿæˆä»£ç çš„ä»£ç ï¼Œä»è€Œæé«˜ä»£ç çš„çµæ´»æ€§å’Œé‡ç”¨æ€§ã€‚æ›´è¯¦å°½çš„è§£é‡Šå¯ä»¥å‚è§æœ¬è¯¾çš„ FAQã€‚Rust ä¸­çš„å®åˆ†ä¸ºä»¥ä¸‹ä¸¤ç§ç±»å‹ï¼š

å£°æ˜å¼å®ï¼ˆDeclarative Macrosï¼‰å…è®¸å¼€å‘è€…ä½¿ç”¨å®è§„åˆ™ï¼ˆmacro_rules!ï¼‰åˆ›å»ºæ¨¡å¼åŒ¹é…å’Œæ›¿æ¢è§„åˆ™ï¼Œæ ¹æ®åŒ¹é…åˆ°çš„æ¨¡å¼è¿›è¡Œä»£ç æ›¿æ¢ã€‚å£°æ˜å¼å®æ˜¯ä¸€ç§åŸºäºæ–‡æœ¬çš„å®ï¼Œå®ƒä»…ä»…æ˜¯ç®€å•çš„æ–‡æœ¬æ›¿æ¢ï¼Œå¹¶æ²¡æœ‰å¯¹è¯­æ³•æ ‘è¿›è¡Œæ“ä½œã€‚

è¿‡ç¨‹å®ï¼ˆProcedural Macrosï¼‰å…è®¸å¼€å‘è€…åœ¨ä»£ç ç”Ÿæˆé˜¶æ®µä½¿ç”¨ Rust ä»£ç æ¥å¤„ç†è¾“å…¥å¹¶ç”Ÿæˆè¾“å‡ºã€‚è€Œéåƒå£°æ˜å¼å®é‚£æ ·åŒ¹é…å¯¹åº”æ¨¡å¼ç„¶åä»¥å¦ä¸€éƒ¨åˆ†ä»£ç æ›¿æ¢å½“å‰ä»£ç ï¼Œå› æ­¤æ˜¯æ›´ä¸ºå¼ºå¤§å’Œçµæ´»çš„å®å½¢å¼ï¼Œè¿‡ç¨‹å®æœ‰ä¸‰ç§ä¸»è¦ç±»å‹ï¼šæ´¾ç”Ÿå®ï¼ˆderive macrosï¼‰ã€å±æ€§å¼å®ï¼ˆattribute-like macrosï¼‰å’Œå‡½æ•°å¼å®ï¼ˆfunction-like macrosï¼‰ã€‚

æ€»ä½“è€Œè¨€ï¼Œå£°æ˜å¼å®ä¸»è¦æ˜¯åŸºäºç®€å•çš„æ–‡æœ¬æ›¿æ¢å’Œæ¨¡å¼åŒ¹é…ï¼Œé€‚ç”¨äºå¯¹ä»£ç è¿›è¡Œç®€å•çš„è½¬æ¢ã€‚è¿‡ç¨‹å®åˆ™æ›´ä¸ºçµæ´»ï¼Œå…è®¸åœ¨ç¼–è¯‘æœŸé—´ç”Ÿæˆå’Œæ“ä½œ ASTï¼Œæä¾›äº†æ›´ä¸°å¯Œçš„åŠŸèƒ½ï¼Œä½†ç›¸å¯¹å¤æ‚ä¸€äº›ï¼Œéœ€è¦æ›´æ·±å…¥çš„ç†è§£å’Œä½¿ç”¨ã€‚é€‰æ‹©å£°æ˜å¼å®è¿˜æ˜¯è¿‡ç¨‹å®é€šå¸¸å–å†³äºæ‰€éœ€åŠŸèƒ½çš„å¤æ‚æ€§å’Œç±»å‹å®‰å…¨çš„è¦æ±‚ã€‚

> ASTï¼ˆAbstract Syntax Treeï¼ŒæŠ½è±¡è¯­æ³•æ ‘ï¼‰ï¼šRust æºä»£ç åœ¨ç¼–è¯‘å™¨ä¸­ä¼šè¢«è§£ææˆè¯æ³•å•å…ƒï¼ˆTokenï¼‰ï¼Œå¹¶è¿›ä¸€æ­¥è§£ææˆä¸€ç§æ ‘çŠ¶ç»“æ„ï¼Œå…¶ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹è¡¨ç¤ºæºä»£ç çš„ä¸€ä¸ªè¯­æ³•ç»“æ„å…ƒç´ ï¼Œæ¯”å¦‚è¡¨è¾¾å¼ã€è¯­å¥ã€å‡½æ•°å£°æ˜ç­‰ã€‚èŠ‚ç‚¹ä¹‹é—´é€šè¿‡æ ‘çŠ¶ç»“æ„ç›¸äº’è¿æ¥ï¼Œåæ˜ äº†æºä»£ç ä¸­çš„åµŒå¥—å’Œå±‚æ¬¡å…³ç³»ã€‚

è¿™é‡Œå±•ç¤ºäº† Rust ä¸­æœ€å¸¸è§çš„ä¸€äº›å®ï¼š

```rs
// æ—¥å¿—æ‰“å°å® println!
println!("hello, micro");

// åŠ¨æ€æ•°ç»„åˆ›å»ºå® vec!
let _dyc_arr = vec![1, 2, 3];

// æ–­è¨€å® assert!ï¼Œåˆ¤æ–­æ¡ä»¶æ˜¯å¦æ»¡è¶³
let x = 1;
let y = 2;
assert!(x + y == 3, "x + y should equal 3");

// æ ¼å¼åŒ–å­—ç¬¦ä¸²çš„å® format!
let name = "world";
let _message = format!("Hello, {}!", name);
```

## å®å’Œå‡½æ•°çš„åŒºåˆ«

åœ¨ Rust ä¸­ï¼Œå®å’Œå‡½æ•°éƒ½æ˜¯ç”¨äºä»£ç é‡ç”¨çš„å·¥å…·ï¼Œä½†å®ƒä»¬ä¹‹é—´æœ‰ä¸€äº›é‡è¦çš„åŒºåˆ«ã€‚

é¦–å…ˆï¼Œå®æ˜¯ä¸€ç§ç¼–è¯‘æ—¶å·¥å…·ï¼Œè€Œå‡½æ•°æ˜¯ä¸€ç§è¿è¡Œæ—¶å·¥å…·ã€‚è¿™æ„å‘³ç€ï¼Œå®åœ¨ç¼–è¯‘æ—¶è¢«å±•å¼€å¹¶ç”Ÿæˆä»£ç ï¼Œè€Œå‡½æ•°åˆ™åœ¨ç¨‹åºè¿è¡Œæ—¶è¢«è°ƒç”¨å¹¶æ‰§è¡Œä»£ç ã€‚å› æ­¤ï¼Œä½¿ç”¨å®å¯ä»¥åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ›´å¤šçš„ä¼˜åŒ–å’Œæ£€æŸ¥ï¼Œä»è€Œæé«˜ç¨‹åºçš„æ€§èƒ½å’Œå®‰å…¨æ€§ã€‚å…¶æ¬¡ï¼Œå®å¯ä»¥æ¥å—ä»»æ„æ•°é‡å’Œç±»å‹çš„å‚æ•°ï¼Œå¹¶ä¸”å¯ä»¥åœ¨ç¼–è¯‘æ—¶ç”Ÿæˆä»»æ„ç±»å‹çš„ä»£ç ã€‚è¿™ä½¿å¾—å®éå¸¸çµæ´»ï¼Œå¯ä»¥ç”¨äºå„ç§ä¸åŒçš„åœºæ™¯ã€‚ä¾‹å¦‚ï¼Œå®å¯ä»¥ç”¨äºç”Ÿæˆæ•°æ®ç»“æ„ã€å®šä¹‰åŸŸç‰¹å®šè¯­è¨€ã€å®ç°ä»£ç æ¨¡æ¿ç­‰ç­‰ã€‚å¦å¤–ï¼Œå®è¿˜å¯ä»¥ä½¿ç”¨ Rust çš„å…ƒç¼–ç¨‹åŠŸèƒ½ï¼Œä¾‹å¦‚å®å®šä¹‰ä¸­çš„ #[derive] å±æ€§å¯ä»¥è‡ªåŠ¨ç”Ÿæˆä»£ç ï¼Œè¿™åœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥å‡å°‘ç¼–å†™ä»£ç çš„å·¥ä½œé‡ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨å®å’Œå‡½æ•°æ¥å®ç°ç›¸åŒçš„åŠŸèƒ½ã€‚å‡è®¾æˆ‘ä»¬è¦ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°†ä¸€ä¸ªå­—ç¬¦ä¸²è½¬æ¢ä¸ºå¤§å†™å­—æ¯ï¼š

```rs
fn to_upper_case(s: &str) -> String {
    s.to_uppercase()
}

fn main() {
    let s = "hello, world!";
    let result = to_upper_case(s);
    println!("{}", result);
}

```

è¿™ä¸ªå‡½æ•°å¾ˆç®€å•ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®æ¥å®ç°åŒæ ·çš„åŠŸèƒ½ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```rs
macro_rules! to_upper_case {
    ($s:expr) => {
        $s.to_uppercase()
    };
}

fn main() {
    let s = "hello, world!";
    let result = to_upper_case!(s);
    println!("{}", result);
}

```

è¿™ä¸ªå®çœ‹èµ·æ¥æ¯”å‡½æ•°æ›´å¤æ‚ï¼Œä½†å®ƒçš„ä¼˜ç‚¹ä¹Ÿå¾ˆæ˜æ˜¾ï¼šå¯ä»¥åœ¨ç¼–è¯‘æ—¶å±•å¼€ï¼Œè¿™ä½¿å¾—å®åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ›´å¤šçš„ä¼˜åŒ–å’Œæ£€æŸ¥ï¼Œä»è€Œæé«˜ç¨‹åºçš„æ€§èƒ½å’Œå®‰å…¨æ€§ã€‚åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå®å±•å¼€åï¼Œåœ¨ç”Ÿæˆçš„ä»£ç ä¸­ç›´æ¥ä½¿ç”¨ to_uppercase æ–¹æ³•ï¼Œè€Œä¸éœ€è¦è°ƒç”¨ to_upper_case å‡½æ•°ï¼Œå‡å°‘äº†ç¨‹åºçš„è¿è¡Œæ—¶é—´å’Œå†…å­˜ä½¿ç”¨ã€‚Rust ç¼–è¯‘å™¨å°†å°†å®å±•å¼€ä¸ºä»¥ä¸‹ä»£ç ï¼š

```rs
let s = "hello, world!";
let result = s.to_uppercase();
println!("{}", result);
```

æ€»ä¹‹ï¼Œå®å’Œå‡½æ•°éƒ½æ˜¯ Rust ä¸­éå¸¸æœ‰ç”¨çš„å·¥å…·ï¼Œéœ€è¦æ ¹æ®å…·ä½“çš„éœ€æ±‚é€‰æ‹©ä½¿ç”¨å“ªç§æ–¹å¼ã€‚

## å£°æ˜å¼å®

å£°æ˜å¼å®ï¼ˆDeclarative Macrosï¼‰é‡‡ç”¨äº†ç±»ä¼¼ match çš„æœºåˆ¶ï¼ˆæ¨¡å¼åŒ¹é…ï¼‰ï¼Œå…è®¸å¼€å‘è€…ä½¿ç”¨å®è§„åˆ™ macro_rules! åˆ›å»ºæ¨¡å¼åŒ¹é…å’Œæ›¿æ¢è§„åˆ™ï¼Œæ ¹æ®åŒ¹é…åˆ°çš„æ¨¡å¼è¿›è¡Œä»£ç æ›¿æ¢ã€‚å£°æ˜å¼å®æ˜¯ä¸€ç§åŸºäºæ–‡æœ¬çš„å®ï¼Œå®ƒä»…ä»…æ˜¯ç®€å•çš„æ–‡æœ¬æ›¿æ¢ï¼Œå¹¶æ²¡æœ‰å¯¹è¯­æ³•æ ‘è¿›è¡Œæ“ä½œã€‚

> è¯­æ³•æ ‘æ˜¯ä»£ç çš„æŠ½è±¡è¡¨ç¤ºï¼Œå®ƒä»¥æ ‘çŠ¶ç»“æ„è¡¨ç¤ºä»£ç çš„è¯­æ³•ç»“æ„ã€‚åœ¨å®ä¸­ï¼Œè¯­æ³•æ ‘æ˜¯ç”±ä¸€ä¸ªä¸ªä»£ç å•å…ƒç»„æˆçš„æŠ½è±¡ç»“æ„ï¼Œç”¨äºè¡¨ç¤ºä»£ç çš„è¯­æ³•å’Œç»“æ„ã€‚å®å¯ä»¥é€šè¿‡æ“ä½œè¯­æ³•æ ‘æ¥ç”Ÿæˆã€ä¿®æ”¹æˆ–é‡ç»„ä»£ç ã€‚

è¿™é‡Œå±•ç¤ºäº†ä¸€ä¸ªç®€å•çš„å£°æ˜å¼å®çš„å®šä¹‰ï¼ˆä½¿ç”¨å…³é”®å­— macro_rules!ï¼‰ï¼Œè¯¥å®é€šè¿‡å‚æ•°ä¸ªæ•°å®ç°äº† 2 ç§æ¨¡å¼åŒ¹é…æœºåˆ¶ã€‚

æ³¨æ„ï¼šRust ç¼–è¯‘å™¨å¯¹è¯¥å®å±•å¼€åï¼Œå¹¶ä¸æ˜¯å¯¹ 2 ä¸ªæ•°è¿›è¡Œäº†æ±‚å’Œè®¡ç®—ï¼Œè€Œæ˜¯å°†å…¶å±•å¼€ä¸º 2 ä¸ªç›¸åŠ çš„æ•°å­—ï¼Œä»£ç å¦‚ä¸‹ï¼š

```rs
// å®çš„å®šä¹‰
macro_rules! add {
		// åŒ¹é… 2 ä¸ªå‚æ•°ï¼Œå¦‚ add!(1,2), add!(2,3)
    ($a:expr,$b:expr) => {
        // macro å®å±•å¼€çš„ä»£ç 
        {
            // è¡¨è¾¾å¼ç›¸åŠ 
            $a + $b
        }
    };

		// åŒ¹é… 1 ä¸ªå‚æ•°ï¼Œå¦‚ add!(1), add!(2)
    ($a:expr) => {{
        $a
    }};
}

fn main() {
		let x = 0;
    // å®çš„ä½¿ç”¨
    add!(1, 2);
    add!(x);
}

// å®å±•å¼€çš„ä»£ç å¦‚ä¸‹
fn main() {
	{
		1 + 2
	}
}
```

## Rust å®ä¸­çš„ Token æ˜¯ä»€ä¹ˆ

Token æ˜¯ Rust ä»£ç çš„æœ€å°å•å…ƒï¼Œå®ƒæ˜¯æºä»£ç ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œä»£è¡¨äº†è¯­æ³•çš„ä¸€éƒ¨åˆ†ã€‚åœ¨ Rust ä¸­ï¼ŒToken å¯ä»¥æ˜¯å…³é”®å­—ã€æ ‡è¯†ç¬¦ã€è¿ç®—ç¬¦ã€ç¬¦å·ç­‰ã€‚åœ¨å®ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ“ä½œå’Œç†è§£è¿™äº› Tokenï¼Œä»¥ä¾¿ç”Ÿæˆæˆ–è½¬æ¢ä»£ç ã€‚

```rs
macro_rules! add {
    ($a:expr,$b:expr) => {{
        $a + $b
    }};
}
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå‚æ•°ä»¥$ä½œä¸ºå¼€å¤´ï¼Œ:åè¡¨æ˜è¯¥å‚æ•°çš„ç±»å‹ï¼Œå‚æ•°ç±»å‹é€šå¸¸è¢«ç§°ä¸º Tokenï¼ŒRust ä¸­å¸¸è§çš„ Token ç±»å‹æœ‰ï¼š

â— è¡¨è¾¾å¼ï¼ˆexprï¼‰ï¼šè¡¨ç¤º Rust ä»£ç ä¸­çš„è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ x + yã€if condition { true } else { false } ç­‰ï¼Œæ•°å­—ä¹Ÿæ˜¯ä¸€ç§è¡¨è¾¾å¼ã€‚

â— è¯­å¥ï¼ˆstmtï¼‰ï¼šè¡¨ç¤º Rust ä»£ç ä¸­çš„è¯­å¥ï¼Œä¾‹å¦‚ let x = 1;ã€println!("Hello, world!"); ç­‰ã€‚

â— ç±»å‹ï¼ˆtyï¼‰ï¼šè¡¨ç¤º Rust ä»£ç ä¸­çš„ç±»å‹ï¼Œä¾‹å¦‚ i32ã€boolã€String ç­‰ã€‚

â— æ ‡è¯†ç¬¦ï¼ˆidentï¼‰ï¼šè¡¨ç¤º Rust ä»£ç ä¸­çš„æ ‡è¯†ç¬¦ï¼Œä¾‹å¦‚å˜é‡åã€å‡½æ•°åã€ç»“æ„ä½“åç­‰ã€‚

â— é€šç”¨ Tokenï¼ˆttï¼‰ï¼šè¡¨ç¤º Rust ä»£ç ä¸­çš„ä»»æ„ Tokenï¼Œå¯ä»¥ç”¨äºåŒ¹é…å’Œç”Ÿæˆä»»æ„ç±»å‹çš„ Tokenã€‚

å£°æ˜å¼å®å¦‚ä½•å®ç°æ¯”å‡½æ•°æ›´åŠ çµæ´»çš„åŠŸèƒ½ï¼Œå¦‚ä¸ç¡®å®šçš„å‚æ•°ç±»å‹ã€éå›ºå®šæ•°é‡çš„å‚æ•°ç­‰ï¼Ÿ

é€šè¿‡ Q1 æˆ‘ä»¬çŸ¥é“ï¼Œå¯ä»¥ä½¿ç”¨æ ‡è®°ç±»å‹ä¸º ty çš„å‚æ•°ä½œä¸ºæ•°æ®ç±»å‹ï¼Œå¦‚ u8ã€u16 ç­‰ã€‚æˆ‘ä»¬æ¥ç€æ”¹ä¸‹ä¸Šé¢çš„ä»£ç ï¼Œä½¿å¾—è¯¥å®åœ¨æ·»åŠ æ•°å­—ä¹‹å‰ï¼Œå°†å…¶è½¬æ¢ä¸ºç‰¹å®šç±»å‹ã€‚

```rs
macro_rules! add_as {
    // ty è¡¨ç¤ºå‚æ•°ç±»å‹
    ($a:expr,$b:expr,$typ:ty) => {
        $a as $typ + $b as $typ
    };
}

fn main() {
		// è¿™é‡Œ add! å®å¯ä»¥ä½¿ç”¨å¤šç§æ•°æ®ç±»å‹
    println!("{}", add_as!(0, 2, u8));
		println!("{}", add_as!(0, 2, u16));
}
```

Rust å®ä¹Ÿæ”¯æŒæ¥å—éå›ºå®šæ•°é‡çš„å‚æ•°ã€‚æ“ä½œç¬¦ä¸æ­£åˆ™è¡¨è¾¾å¼éå¸¸ç›¸ä¼¼ï¼Œ\*ç”¨äºé›¶ä¸ªæˆ–å¤šä¸ªæ ‡è®°ç±»å‹ï¼Œ+ç”¨äºé›¶ä¸ªæˆ–ä¸€ä¸ªå‚æ•°ã€‚

```rs
macro_rules! add{
    // åŒ¹é…å•ä¸ªå‚æ•°
    ($a:expr)=>{
       $a
    };
   // åŒ¹é… 2 ä¸ªå‚æ•°
    ($a:expr,$b:expr)=>{
       {
           $a+$b
       }
    };
   // é€’å½’è°ƒç”¨
    ($a:expr,$($b:tt)*)=>{
        {
            $a+add!($($b)*)
        }
    }
}

fn main() {
    println!("{}", add!(1, 2, 3, 4));
}
```

é‡å¤çš„æ ‡è®°ç±»å‹åŒ…å«åœ¨$() ä¸­ï¼Œåé¢è·Ÿç€ä¸€ä¸ª*æˆ–+ï¼Œè¡¨ç¤ºè¯¥æ ‡è®°å°†é‡å¤çš„æ¬¡æ•°ã€‚$($b:tt)*è¡¨ç¤º tt ç±»å‹çš„å‚æ•°$bï¼Œå¯ä»¥é‡å¤ 0~N æ¬¡ï¼Œè€Œ add!($($b)\*) åˆ™è¡¨ç¤ºå¤šä¸ª$bä¼šé€’å½’è°ƒç”¨ add! å®ï¼Œå› æ­¤ä¹Ÿå°±å®ç°äº†éå›ºå®šæ•°é‡çš„å‚æ•°è°ƒç”¨ã€‚

## æ´¾ç”Ÿå®ï¼ˆDerive Macrosï¼‰

æ´¾ç”Ÿå®ï¼ˆDerive Macrosï¼‰ï¼šé€šå¸¸ç”¨äºä¸º struct ç»“æ„ä½“ã€enum æšä¸¾ã€union ç±»å‹å®ç° Trait ç‰¹å¾ï¼ˆè§ 4.5 èŠ‚ Trait ç‰¹å¾ï¼‰ã€‚ä½¿ç”¨æ—¶é€šè¿‡#[derive(CustomMacro)]è¿™æ ·çš„è¯­æ³•ï¼Œå…è®¸ç”¨æˆ·è½»æ¾åœ°ä¸ºè‡ªå®šä¹‰ç±»å‹æä¾›ä¸€äº›é€šç”¨çš„å®ç°ã€‚å‰æ–‡æåˆ°ä¸‰ç§è¿‡ç¨‹å® (æ´¾ç”Ÿå®ã€å±æ€§å®ã€å‡½æ•°å®)ï¼Œå®ƒä»¬çš„å·¥ä½œæ–¹å¼éƒ½æ˜¯ç±»ä¼¼çš„ï¼šä½¿ç”¨ Rust çš„æºä»£ç ä½œä¸ºè¾“å…¥å‚æ•°ï¼ŒåŸºäºä»£ç è¿›è¡Œä¸€ç³»åˆ—æ“ä½œåï¼Œå†è¾“å‡ºä¸€æ®µå…¨æ–°çš„ä»£ç ã€‚

ä¸€ä¸ªè¿‡ç¨‹å®çš„ç®€å•æ¡†æ¶å¦‚ä¸‹ï¼š

```rs
use proc_macro::TokenStream;

// æ ‡è®°ç±»å®çš„ç±»å‹
#[proc_macro_derive(CustomMacro)]
pub fn custom_macro_derive(input: TokenStream) -> TokenStream {
    TokenStream::new()
}
```

proc_macro_derive ç¨å¾®ç‰¹æ®Šä¸€äº›ï¼Œå› ä¸ºå®ƒéœ€è¦ä¸€ä¸ªé¢å¤–çš„æ ‡è¯†ç¬¦ï¼Œæ­¤æ ‡è¯†ç¬¦å°†æˆä¸º derive å®çš„å®é™…åç§°ï¼Œå¦‚ CustomMacroã€Cloneã€Copy ç­‰ã€‚

input è¾“å…¥æ ‡è®°æµæ˜¯æ·»åŠ äº† derive å±æ€§çš„ç±»å‹ï¼Œå®ƒå°†å§‹ç»ˆæ˜¯ enumã€struct æˆ–è€… union ç±»å‹ï¼Œå› ä¸ºåªæœ‰è¿™äº›ç±»å‹æ‰å¯ä»¥ä½¿ç”¨ derive æ´¾ç”Ÿå®ã€‚

éœ€è¦è¯´æ˜çš„æ˜¯ï¼Œè¿‡ç¨‹å®ä¸­çš„æ´¾ç”Ÿå®è¾“å‡ºçš„ä»£ç å¹¶ä¸ä¼šæ›¿æ¢ä¹‹å‰çš„ä»£ç ï¼Œè€Œæ˜¯åœ¨åŸæ¥ä»£ç åŸºç¡€ä¸Šè¿½åŠ æŒ‡å®šå®çš„ Trait å®ç°

ä¸‹é¢çš„ä»£ç æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ª Foo ç»“æ„ä½“ï¼Œé€šå¸¸æƒ…å†µä¸‹ struct æœ‰è®¸å¤š Trait è¦å®ç°ã€‚è¿™é‡Œä½¿ç”¨äº† 2 ç§æ–¹å¼ï¼Œä¸€ç§æ˜¯å¸¸è§„çš„ implï¼Œå¦ä¸€ç§æ˜¯ä½¿ç”¨å®

```rs
struct Foo { x: i32, y: i32 }

// æ–¹å¼ä¸€
impl Copy for Foo { ... }
impl Clone for Foo { ... }
impl Ord for Foo { ... }
impl PartialOrd for Foo { ... }
impl Eq for Foo { ... }
impl PartialEq for Foo { ... }
impl Debug for Foo { ... }
impl Hash for Foo { ... }

// æ–¹å¼äºŒ
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug, Hash, Default)]
struct Foo { x: i32, y: i32 }
```

è¿™ç§æƒ…å†µä¸‹æ˜¾ç„¶é€šè¿‡ derive å®æ›´åŠ æ–¹ä¾¿ã€‚ä½†ä»¥ä¸Šä¸¤ç§æ–¹å¼å¹¶æ²¡æœ‰å­°ä¼˜å­°åŠ£ï¼Œä¸»è¦åœ¨äºä¸åŒçš„ç±»å‹æ˜¯å¦å¯ä»¥ä½¿ç”¨åŒæ ·çš„é»˜è®¤ç‰¹å¾å®ç°ï¼Œå¦‚æœå¯ä»¥ï¼Œé‚£è¿‡ç¨‹å®çš„æ–¹å¼å¯ä»¥å¸®æˆ‘ä»¬å‡å°‘å¾ˆå¤šä»£ç å®ç°ã€‚

æ´¾ç”Ÿå®çš„å®ç°åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ

æˆ‘ä»¬ä»¥ HelloMacro è¿™ä¸ª Trait ç‰¹å¾ä¸ºä¾‹ï¼Œè¿™é‡Œæœ‰ MyStruct å’Œ YourStruct è¿™ 2 ä¸ªç»“æ„ä½“å®ç°äº† Trait ç‰¹å¾çš„ hello_macro() å‡½æ•°ï¼Œå¹¶æ‰“å°å‡ºå¯¹åº”çš„ç»“æ„ä½“çš„åç§°ã€‚

```rs
// è¿™æ˜¯ä¸€ä¸ªé€šç”¨çš„ Trait ç‰¹å¾
trait HelloMacro {
	fn hello_macro();
}

// è‡ªå®šä¹‰ç»“æ„ä½“ MyStructï¼Œå¹¶å®ç°å¦‚ä¸Šç‰¹å¾
struct MyStruct;
impl HelloMacro for MyStruct {
	fn hello_macro() {
		println!("Hello, Macro! My name is MyStruct!");
	}
}

// è‡ªå®šä¹‰ç»“æ„ä½“ YourStructï¼Œå¹¶å®ç°å¦‚ä¸Šç‰¹å¾
struct YourStruct;
impl HelloMacro for YourStruct {
	fn hello_macro() {
		println!("Hello, Macro! My name is YourStruct!");
	}
}

fn main() {
	MyStruct::hello_macro();
	YourStruct::hello_macro();
}
```

è¿™ä¸ª HelloMacro ç‰¹å¾å¯ä»¥å¯¹ä»»æ„ç»“æ„ä½“ä½¿ç”¨ï¼Œå¹¶ä¸”åœ¨æ‰“å°æ—¥å¿—ä¸­è‡ªåŠ¨æ›¿æ¢æˆç»“æ„ä½“çš„åç§°ï¼Œå› æ­¤æŠŠå®ƒå®šä¹‰ä¸ºå®æ˜¯æ¯”è¾ƒåˆé€‚çš„ã€‚æŒ‰ç…§è¿‡ç¨‹å®å®šä¹‰çš„æ¨¡æ¿ï¼Œæˆ‘ä»¬å®ç°å¦‚ä¸‹çš„ä»£ç ï¼š

```rs
// å¼•å…¥å®ç›¸å…³çš„ä¾èµ–
extern crate proc_macro;
use proc_macro::TokenStream;
use quote::quote;
use syn;
use syn::DeriveInput;

// HelloMacro å®çš„å®ç°é€»è¾‘
#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
	let ast:DeriveInput = syn::parse(input).unwrap();
	impl_hello_macro(&ast)
}
```

å‰å‡ è¡Œä»£ç å¼•å…¥äº† macro ç›¸å…³çš„ä¾èµ–ï¼šRust çš„ quote å’Œ syn åº“ï¼Œå…¶ä¸­ syn åº“ç”¨äºè§£æ Rust ä»£ç çš„ ASTï¼ˆæŠ½è±¡è¯­æ³•æ ‘ï¼‰ï¼Œè€Œ quote åº“ç”¨äºç”Ÿæˆ Rust ä»£ç ã€‚

ä¸»ä½“å‡½æ•°é¦–å…ˆä½¿ç”¨ syn::parse å‡½æ•°è§£æè¾“å…¥çš„ TokenStreamï¼Œå¹¶å°†å…¶è½¬æ¢ä¸º DeriveInput ç±»å‹çš„ astã€‚ç„¶åï¼Œå®ƒè°ƒç”¨ impl_hello_macro å‡½æ•°ï¼Œå°† ast ä½œä¸ºå‚æ•°ä¼ é€’ç»™å®ƒï¼Œç”Ÿæˆå®ç° HelloMacro ç‰¹å¾çš„ Rust ä»£ç ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸º TokenStreamï¼Œå¹¶è¿”å›ç»™è°ƒç”¨è€…ã€‚å› æ­¤ï¼Œå½“ç”¨æˆ·ä½¿ç”¨#[derive(HelloMacro)]æ ‡è®°äº†ä»–çš„ç±»å‹åï¼ŒRust ç¼–è¯‘å™¨åœ¨ç¼–è¯‘å‰ä¼šè°ƒç”¨ hello_macro_derive å‡½æ•°ï¼Œç”Ÿæˆç›¸åº”çš„ä»£ç ï¼Œå³å®çš„å±•å¼€ã€‚

åœ¨ä»‹ç» impl_hello_macro å‡½æ•°ä¹‹å‰ï¼Œæˆ‘ä»¬å†æ¥å›é¡¾ä¸‹ä¸ŠèŠ‚æåˆ°çš„ Token æ¦‚å¿µï¼ŒToken æ˜¯ Rust ä»£ç çš„æœ€å°å•å…ƒï¼Œå®ƒæ˜¯æºä»£ç ä¸­çš„ä¸€ä¸ªå…ƒç´ ï¼Œä»£è¡¨äº†è¯­æ³•çš„ä¸€éƒ¨åˆ†ã€‚åœ¨ Rust ä¸­ï¼ŒToken å¯ä»¥æ˜¯å…³é”®å­—ã€æ ‡è¯†ç¬¦ã€è¿ç®—ç¬¦ã€ç¬¦å·ç­‰ã€‚åœ¨å®ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ“ä½œå’Œç†è§£è¿™äº› Tokenï¼Œä»¥ä¾¿ç”Ÿæˆæˆ–è½¬æ¢ä»£ç ã€‚

ä¾‹å¦‚ï¼Œåœ¨ Rust ä¸­ï¼Œlet x = 5;è¿™è¡Œä»£ç å¯ä»¥è¢«åˆ†è§£ä¸ºä»¥ä¸‹ Tokenï¼š

â—`let`: å…³é”®å­—

â—`x`: æ ‡è¯†ç¬¦

â—``=` : èµ‹å€¼è¿ç®—ç¬¦

â— `5` : æ•°å­—å­—é¢é‡

â— `;` : åˆ†å·

è€Œ TokenStream åˆ™æ˜¯ç”±ä¸€ç³»åˆ— Token ç»„æˆçš„åºåˆ—ï¼Œå®ƒæ˜¯åœ¨å®å±•å¼€æœŸé—´ä¼ é€’å’Œæ“ä½œçš„æ•°æ®ç±»å‹ã€‚å®ƒè¡¨ç¤ºä¸€æ®µè¢«è§£æå’Œå¤„ç†è¿‡çš„ä»£ç ã€‚TokenStream å¯ä»¥åŒ…å«å¤šä¸ª Tokenï¼Œå®ƒä»¬ç»„æˆäº†ä¸€ä¸ªä»£ç ç‰‡æ®µã€‚åœ¨å®ä¸­ï¼Œé€šå¸¸ä¼šæ¥æ”¶ä¸€ä¸ª TokenStream ä½œä¸ºè¾“å…¥ï¼Œå¯¹å…¶ä¸­çš„ Token è¿›è¡Œå¤„ç†ï¼Œç„¶åç”Ÿæˆä¸€ä¸ªæ–°çš„ TokenStream ä½œä¸ºè¾“å‡ºã€‚è¿™ç§æ–¹å¼å…è®¸åœ¨ç¼–è¯‘æ—¶è¿›è¡Œä»£ç ç”Ÿæˆæˆ–ä»£ç è½¬æ¢ã€‚å†æ¥çœ‹ä¸€ä¸‹ä¸€ä¸ªç»“æ„ä½“ç”±å“ªäº›éƒ¨åˆ†ç»„æˆï¼š

```rs
// visï¼Œå¯è§†èŒƒå›´ Â  å…³é”®å­—Â  Â  identï¼Œæ ‡è¯†ç¬¦ Â  genericï¼ŒèŒƒå‹
pubÂ  Â  Â  Â  Â  Â  Â  structÂ  Â  UserÂ  Â  Â  Â  Â  Â  <T>Â  Â  Â  Â  {
	// fields: ç»“æ„ä½“çš„å­—æ®µ
	// vis Â  ident Â  type
	pub Â      name: Â  &T,
}
```

â— `pub` : å¯è§†èŒƒå›´ï¼Œåœ¨å®ä¸­é€šè¿‡ vis æ¥è¡¨ç¤ºï¼Œè¡¨ç¤ºæ ‡è¯†ç¬¦ã€æ¨¡å—ã€ç»“æ„ä½“ç­‰çš„è®¿é—®æƒé™ã€‚

â— `struct` : å…³é”®å­— keywordï¼Œä¾‹å¦‚ fnã€structã€if ç­‰ã€‚

â— `User`: æ ‡è¯†ç¬¦ identï¼Œä¾‹å¦‚å˜é‡åã€å‡½æ•°åç­‰ã€‚

â— `<T>`ï¼šèŒƒå‹ generic

â— `fields`ï¼šç»“æ„ä½“å­—æ®µçš„é›†åˆ

â— `T`ï¼šåœ¨ pub name: &T ä¸­è¡¨ç¤º ident çš„ type ç±»å‹ï¼Œä»£ç ä¸­çš„ç±»å‹æ ‡è¯†ç¬¦ï¼Œä¾‹å¦‚ i32ã€String ç­‰ã€‚

syn::parse è°ƒç”¨ä¼šè¿”å›ä¸€ä¸ª DeriveInput ç»“æ„ä½“æ¥ä»£è¡¨è§£æåçš„ Rust ä»£ç ï¼Œåç»­é€»è¾‘æˆ‘ä»¬å°±æ˜¯åœ¨æ­¤åŸºç¡€ä¸Šè°ƒæ•´ç›¸åº”çš„ Rust ä»£ç ï¼Œè¿™é‡Œå¤§å®¶ä¹Ÿè®¸æ›´å®¹æ˜“ç†è§£ä¸ºä»€ä¹ˆè¯´å®æ˜¯ä¸€ç§å…ƒç¼–ç¨‹äº†ï¼šç¼–å†™ Rust ä»£ç çš„ä»£ç ã€‚

```rs
DeriveInput {
	// --snip--
	vis: Visibility,
	ident: Ident {
		ident: "MyStruct",
		span: #0 bytes(95..103)
	},
	generics: Generics,

	// Data æ˜¯ä¸€ä¸ªæšä¸¾ï¼Œåˆ†åˆ«æ˜¯ DataStructï¼ŒDataEnumï¼ŒDataUnionï¼Œè¿™é‡Œä»¥ DataStruct ä¸ºä¾‹
	data: Data(
		DataStruct {
			struct_token: Struct,
			fields: Fields,
			semi_token: Some(
				Semi
			)
		}
	)
}
```

æ¥ä¸‹æ¥çœ‹ä¸‹å¦‚ä½•æ„å»ºç‰¹å¾å®ç°çš„ä»£ç ï¼Œä¹Ÿæ˜¯è¿‡ç¨‹å®çš„å…·ä½“å®ç°é€»è¾‘ï¼š

```rs
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {

    let name = &ast.ident;
    let gen = quote! {
				// å®ç° HelloMacro ç‰¹å¾
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

é¦–å…ˆï¼Œå°†ç»“æ„ä½“çš„åç§°èµ‹äºˆç»™ nameï¼Œä¹Ÿå°±æ˜¯ name ä¸­ä¼šåŒ…å«ä¸€ä¸ªå­—æ®µï¼Œå®ƒçš„å€¼æ˜¯å­—ç¬¦ä¸² MyStructã€‚

å…¶æ¬¡ï¼Œä½¿ç”¨ quote! å¯ä»¥å®šä¹‰æˆ‘ä»¬æƒ³è¦è¿”å›çš„ Rust ä»£ç ã€‚ç”±äºç¼–è¯‘å™¨éœ€è¦çš„å†…å®¹å’Œ quote! ç›´æ¥è¿”å›çš„ä¸ä¸€æ ·ï¼Œå› æ­¤è¿˜éœ€è¦ä½¿ç”¨.into æ–¹æ³•å…¶è½¬æ¢ä¸º TokenStreamã€‚

ç‰¹å¾çš„ hell_macro() å‡½æ•°åªæœ‰ä¸€ä¸ªåŠŸèƒ½ï¼Œå°±æ˜¯ä½¿ç”¨ println! æ‰“å°ä¸€è¡Œæ¬¢è¿è¯­å¥ï¼Œä½¿ç”¨ stringify! è·å–#name çš„å­—é¢å€¼å½¢å¼ã€‚æœ‰äº†è¿™ä¸ªå®ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥ç”¨å®ƒæ¥æ ‡è®°ç»“æ„ä½“

```rs
#[derive(HelloMacro)]
struct MyStruct;
```

## å±æ€§å¼å®

å±æ€§å¼å®ï¼ˆattribute-like macroï¼‰ï¼šå®šä¹‰äº†å¯æ·»åŠ åˆ°æ ‡è®°å¯¹è±¡çš„æ–°å¤–éƒ¨å±æ€§ã€‚è¿™ç§å®é€šè¿‡#[attr]æˆ–#[attr(â€¦)]æ–¹å¼è°ƒç”¨ï¼Œå…¶ä¸­â€¦æ˜¯æ ‡è®°çš„å…·ä½“å±æ€§ï¼ˆå¯é€‰ï¼‰ã€‚ä¸€ä¸ªå±æ€§å¼å®å®šä¹‰çš„ç®€å•æ¡†æ¶å¦‚ä¸‹æ‰€ç¤ºï¼š

```rs
use proc_macro::TokenStream;

// è¿™é‡Œæ ‡è®°å®çš„ç±»å‹
#[proc_macro_attribute]
pub fn custom_attribute(input: TokenStream, annotated_item: TokenStream) -> TokenStream {
    annotated_item
}
```

è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸æ´¾ç”Ÿå®ã€å‡½æ•°å¼å®ä¸åŒï¼Œå±æ€§å¼å®æœ‰ä¸¤ä¸ªè¾“å…¥å‚æ•°ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªã€‚

â— ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å±æ€§åç§°åé¢çš„å¸¦åˆ†éš”ç¬¦çš„æ ‡è®°é¡¹ï¼ˆå³#[attr(â€¦)]ä¸­ (â€¦) çš„å…·ä½“å†…å®¹ï¼‰ã€‚å¦‚æœåªæœ‰å±æ€§åç§°ï¼ˆå…¶åä¸å¸¦æ ‡è®°é¡¹ï¼Œæ¯”å¦‚ #[attr]ï¼‰ï¼Œåˆ™è¿™ä¸ªå‚æ•°çš„å€¼ä¸ºç©ºã€‚

â— ç¬¬äºŒä¸ªå‚æ•°æ˜¯æ ‡è®°çš„ä»£ç é¡¹æœ¬èº«çš„ Token æµï¼Œå®ƒå¯ä»¥æ˜¯è¢«æ ‡è®°çš„å­—æ®µã€ç»“æ„ä½“ã€å‡½æ•°ç­‰ï¼ˆè§çœŸå®ç”¨ä¾‹ï¼‰ã€‚

å¦‚ä¸‹çš„ä»£ç å±•ç¤ºäº†ä¸€äº›å¸¸è§çš„å±æ€§å¼å®ï¼š#[cfg(â€¦)]æ˜¯æ ¹æ®æ¡ä»¶ç¼–è¯‘çš„å±æ€§å®ã€#[test]æ˜¯ç”¨äºæ ‡è®°æµ‹è¯•å‡½æ•°çš„å±æ€§å®ã€#[allow(...)]å’Œ #[warn(...)]æ§åˆ¶ç¼–è¯‘å™¨çš„è­¦å‘Šçº§åˆ«ã€‚

```rs
// ç”¨äºæ ¹æ®æ¡ä»¶é€‰æ‹©æ€§åœ°åŒ…å«æˆ–æ’é™¤ä»£ç 
#[cfg(feature = "some_feature")]
fn conditional_function() {
    // ä»…åœ¨ç‰¹å®šç‰¹æ€§å¯ç”¨æ—¶æ‰ç¼–è¯‘æ­¤å‡½æ•°
}

#[test]
fn my_test() {
    // æµ‹è¯•å‡½æ•°
}

#[allow(unused_variables)]
fn unused_variable() {
    // å…è®¸æœªä½¿ç”¨çš„å˜é‡
}
```

## å‡½æ•°å¼å®ï¼ˆfunction-like macroï¼‰

å‡½æ•°å¼å®é‡‡ç”¨ proc_macro! å…³é”®å­—å®šä¹‰ï¼Œé€šè¿‡ custom_fn_macro!(â€¦) çš„æ–¹å¼æ¥è°ƒç”¨ã€‚ä½†ä¸åŒäºå£°æ˜å¼å®ä½¿ç”¨æ¨¡å¼åŒ¹é…çš„æ–¹å¼ï¼Œå‡½æ•°å®åˆ™æ›´åƒæ˜¯å¸¸è§„çš„å‡½æ•°è°ƒç”¨ï¼Œå¯ä»¥ä½¿ç”¨å„ç§ Rust è¯­æ³•ï¼ŒåŒ…æ‹¬æ¡ä»¶è¯­å¥ã€å¾ªç¯ã€æ¨¡å¼åŒ¹é…ç­‰ï¼Œä½¿å¾—å®ƒæ›´åŠ çµæ´»å’Œå¼ºå¤§ã€‚

å‡½æ•°å¼çš„å®šä¹‰ç®€å•ç¼–å†™æ¡†æ¶å¦‚ä¸‹æ‰€ç¤ºï¼š

```rs
use proc_macro::TokenStream;

// è¿™é‡Œæ ‡è®°å®çš„ç±»å‹
#[proc_macro]
pub fn custom_fn_macro(input: TokenStream) -> TokenStream {
    input
}
```

å¯ä»¥çœ‹åˆ°ï¼Œè¿™å®é™…ä¸Šåªæ˜¯ä»ä¸€ä¸ª TokenStream åˆ°å¦ä¸€ä¸ª TokenStream çš„æ˜ å°„ï¼Œå…¶ä¸­ input æ˜¯è°ƒç”¨åˆ†éš”ç¬¦å†…çš„æ ‡è®°é¡¹ã€‚

ä¾‹å¦‚ï¼Œå¯¹äºç¤ºä¾‹è°ƒç”¨ foo!(bar)ï¼Œinput è¾“å…¥æ ‡è®°æµå³ä¸º barã€‚è¿”å›çš„æ ‡è®°æµå°†æ›¿æ¢å®è°ƒç”¨ã€‚

# é¡¹ç›®ç»“æ„

moduleï¼šç”¨äºç»„ç»‡å’Œå°è£…ä»£ç çš„å•å…ƒã€‚å®ƒå¯ä»¥åŒ…å«å‡½æ•°ã€ç»“æ„ä½“ã€æšä¸¾ã€å¸¸é‡ã€Trait ç­‰ï¼Œä¹Ÿå¯ä»¥åŒ…å«å…¶ä»–æ¨¡å—ã€‚é€šè¿‡ä½¿ç”¨ mod å…³é”®å­—å¯ä»¥åœ¨ Rust ä¸­åˆ›å»ºæ¨¡å—ï¼Œå¹¶ä¸”æ¨¡å—å¯ä»¥åµŒå¥—å½¢æˆæ¨¡å—æ ‘ã€‚

crateï¼šæ˜¯ Rust ä¸­çš„ç¼–è¯‘å•å…ƒï¼Œå¯ä»¥æ˜¯åº“ crate æˆ–äºŒè¿›åˆ¶ crateï¼ˆå®ƒä»¬çš„åŒºåˆ«å‚è§ FAQï¼‰ã€‚ä¸€ä¸ª crate å¯ä»¥åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªæ¨¡å—ã€‚

packageï¼šæ˜¯ä¸€ä¸ªåŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªç›¸å…³ crate çš„é¡¹ç›®å·¥ç¨‹ã€‚å®ƒç”±ä¸€ä¸ª Cargo.toml æ–‡ä»¶å®šä¹‰ï¼Œè¯¥æ–‡ä»¶åŒ…å«æœ‰å…³é¡¹ç›®çš„å…ƒä¿¡æ¯ã€ä¾èµ–å…³ç³»ä»¥åŠå…¶ä»–é…ç½®é€‰é¡¹ã€‚ä¸€ä¸ª package å¯èƒ½åŒ…å«ä¸€ä¸ªä¸» crateï¼ˆé€šå¸¸æ˜¯å¯æ‰§è¡Œæ–‡ä»¶ï¼‰å’Œé›¶ä¸ªæˆ–å¤šä¸ªåº“ crateï¼ˆé€šå¸¸æ˜¯ä¾èµ– crateï¼‰ã€‚

ä¸‹é¢çš„ä»£ç åˆ†åˆ«å±•ç¤ºäº†æ¨¡å—ï¼ˆmoduleï¼‰çš„å®šä¹‰ã€‚

```rs
// mod å®šä¹‰ä¸€ä¸ªæ¨¡å—ï¼Œåé¢è·Ÿç€æ¨¡å—åï¼ˆmy_moduleï¼‰
mod my_module {
    // æ¨¡å—çš„å†…å®¹
    pub fn my_function() {
        // å‡½æ•°ä½“
    }
}
```

## Rust ä¸­ åº“ crate å’ŒäºŒè¿›åˆ¶ crate çš„æ¦‚å¿µ

åº“ crate å’ŒäºŒè¿›åˆ¶ crate æ˜¯ä¸¤ç§ä¸åŒç±»å‹çš„ Rust é¡¹ç›®ã€‚å®ƒä»¬åˆ†åˆ«ç”¨äºæ„å»ºåº“ï¼ˆç”¨äºè¢«å…¶ä»–ç¨‹åºå¼•ç”¨ï¼‰å’Œå¯æ‰§è¡Œç¨‹åºã€‚æˆ‘ä»¬åˆ†åˆ«çœ‹ä¸‹å®ƒä»¬çš„æ¦‚å¿µåŠåŒºåˆ«ï¼š

åº“ crateï¼šæ˜¯ä¸€ç§ Rust é¡¹ç›®ï¼Œé€šè¿‡ cargo new --lib åº“åæ¥åˆ›å»ºï¼Œå®ƒçš„ä¸»è¦ç›®çš„æ˜¯æä¾›å¯ä¾›å…¶ä»–ç¨‹åºå¼•ç”¨çš„åŠŸèƒ½æ€§ä»£ç ã€‚åº“ crate çš„ä»£ç é€šå¸¸æ˜¯ä¸€äº›é€šç”¨çš„ã€å¯å¤ç”¨çš„åŠŸèƒ½ã€‚

ç»„ç»‡æ–¹å¼ï¼šä¸€ä¸ªåº“ crate çš„ä»£ç é€šå¸¸ä½äºä¸€ä¸ªåä¸º lib.rs çš„æ–‡ä»¶ä¸­ï¼Œè¯¥æ–‡ä»¶åŒ…å« crate çš„ä¸»æ¨¡å—ã€‚åº“ crate çš„ä»£ç å¯ä»¥ç”±å…¶ä»– crate å¼•ç”¨ï¼Œé€šè¿‡åœ¨ Cargo.toml æ–‡ä»¶ä¸­æ·»åŠ ç›¸åº”çš„ä¾èµ–ã€‚

äºŒè¿›åˆ¶ crateï¼šä¹Ÿæ˜¯ä¸€ç§ Rust é¡¹ç›®ï¼Œé€šè¿‡ cargo new é¡¹ç›®åæ¥åˆ›å»ºï¼Œå®ƒçš„ä¸»è¦ç›®çš„æ˜¯æ„å»ºå¯æ‰§è¡Œç¨‹åºã€‚è¿™ä¸ª crate å¯ä»¥åŒ…å«å¤šä¸ªæ¨¡å—ï¼Œå…¶ä¸­ä¸€ä¸ªæ¨¡å—è¢«æŒ‡å®šä¸ºä¸»å…¥å£ç‚¹ï¼Œä¾‹å¦‚ main.rs æ–‡ä»¶ã€‚äºŒè¿›åˆ¶ crate çš„ä»£ç ç”¨äºåˆ›å»ºç‹¬ç«‹çš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚

ç»„ç»‡æ–¹å¼ï¼šä¸€ä¸ªäºŒè¿›åˆ¶ crate çš„ä»£ç é€šå¸¸åŒ…å«åœ¨ä¸€ä¸ªåä¸º main.rs çš„æ–‡ä»¶ä¸­ï¼Œè¯¥æ–‡ä»¶åŒ…å«ç¨‹åºçš„ä¸»å‡½æ•° main()ã€‚

æ€»çš„æ¥è¯´ï¼Œåº“ crateï¼Œç”¨äºæ„å»ºå¯ä¾›å…¶ä»–ç¨‹åºå¼•ç”¨çš„åŠŸèƒ½æ€§ä»£ç ï¼›ä»£ç é€šå¸¸ä½äº lib.rs æ–‡ä»¶ä¸­ï¼›å¯ä»¥è¢«å…¶ä»– crate å¼•ç”¨ä½œä¸ºä¾èµ–ã€‚è€ŒäºŒè¿›åˆ¶ crateï¼Œç”¨äºæ„å»ºå¯æ‰§è¡Œç¨‹åºï¼›ä»£ç é€šå¸¸ä½äº main.rs æ–‡ä»¶ä¸­ï¼›äº§ç”Ÿä¸€ä¸ªç‹¬ç«‹çš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚

æ³¨æ„ï¼šåœ¨ä¸€ä¸ª Rust é¡¹ç›®ä¸­ï¼Œä½ å¯ä»¥åŒæ—¶åŒ…å«åº“ crate å’ŒäºŒè¿›åˆ¶ crateã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªé¡¹ç›®å¯èƒ½åŒ…å«ä¸€ä¸ªåº“ç”¨äºæä¾›é€šç”¨åŠŸèƒ½ï¼ŒåŒæ—¶ä¹ŸåŒ…å«ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºç”¨äºæ¼”ç¤ºæˆ–æµ‹è¯•è¯¥åº“ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé¡¹ç›®çš„ç›®å½•ç»“æ„é€šå¸¸åŒ…å« src/lib.rs å’Œ src/main.rsã€‚
